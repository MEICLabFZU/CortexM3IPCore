; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\os_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\include -I.\TTS -I.\OLED -I.\ucosii\config -I.\ucosii\port -I.\ucosii\source -I.\RTE\_Target_1 -ID:\Coding\MDKeil\ARM\PACK\ARM\CMSIS\5.4.0\Device\ARM\ARMCM3\Include -ID:\Coding\MDKeil\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DARMCM3 --omf_browse=.\objects\os_core.crf ucosii\source\os_core.c]
                          THUMB

                          AREA ||i.OSEventNameGet||, CODE, READONLY, ALIGN=2

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;120            return (0);
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00000c  4815              LDR      r0,|L1.100|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  2800              CMP      r0,#0
000012  dd04              BLE      |L1.30|
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
000014  2011              MOVS     r0,#0x11
000016  7020              STRB     r0,[r4,#0]
;;;133            return (0);
000018  2000              MOVS     r0,#0
                  |L1.26|
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.30|
00001e  7828              LDRB     r0,[r5,#0]            ;135
000020  2801              CMP      r0,#1                 ;135
000022  d008              BEQ      |L1.54|
000024  2802              CMP      r0,#2                 ;135
000026  d007              BEQ      |L1.56|
000028  2803              CMP      r0,#3                 ;135
00002a  d002              BEQ      |L1.50|
00002c  2804              CMP      r0,#4                 ;135
00002e  d104              BNE      |L1.58|
000030  e000              B        |L1.52|
                  |L1.50|
000032  bf00              NOP                            ;137
                  |L1.52|
000034  bf00              NOP                            ;138
                  |L1.54|
000036  bf00              NOP                            ;139
                  |L1.56|
000038  e003              B        |L1.66|
                  |L1.58|
00003a  2001              MOVS     r0,#1                 ;143
00003c  7020              STRB     r0,[r4,#0]            ;143
00003e  2000              MOVS     r0,#0                 ;144
000040  e7eb              B        |L1.26|
                  |L1.66|
000042  bf00              NOP                            ;140
000044  f7fffffe          BL       OS_CPU_SR_Save
000048  4607              MOV      r7,r0                 ;146
00004a  f105010f          ADD      r1,r5,#0xf            ;147
00004e  4630              MOV      r0,r6                 ;147
000050  f7fffffe          BL       OS_StrCopy
000054  4680              MOV      r8,r0                 ;147
000056  4638              MOV      r0,r7                 ;148
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  2000              MOVS     r0,#0                 ;149
00005e  7020              STRB     r0,[r4,#0]            ;149
000060  4640              MOV      r0,r8                 ;150
000062  e7da              B        |L1.26|
;;;152    #endif
                          ENDP

                  |L1.100|
                          DCD      OSIntNesting

                          AREA ||i.OSEventNameSet||, CODE, READONLY, ALIGN=2

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00000e  481a              LDR      r0,|L2.120|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  2800              CMP      r0,#0
000014  dd03              BLE      |L2.30|
;;;206            *perr = OS_ERR_NAME_SET_ISR;
000016  2012              MOVS     r0,#0x12
000018  7020              STRB     r0,[r4,#0]
                  |L2.26|
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L2.30|
00001e  7828              LDRB     r0,[r5,#0]            ;209
000020  2801              CMP      r0,#1                 ;209
000022  d008              BEQ      |L2.54|
000024  2802              CMP      r0,#2                 ;209
000026  d007              BEQ      |L2.56|
000028  2803              CMP      r0,#3                 ;209
00002a  d002              BEQ      |L2.50|
00002c  2804              CMP      r0,#4                 ;209
00002e  d104              BNE      |L2.58|
000030  e000              B        |L2.52|
                  |L2.50|
000032  bf00              NOP                            ;211
                  |L2.52|
000034  bf00              NOP                            ;212
                  |L2.54|
000036  bf00              NOP                            ;213
                  |L2.56|
000038  e002              B        |L2.64|
                  |L2.58|
00003a  2001              MOVS     r0,#1                 ;217
00003c  7020              STRB     r0,[r4,#0]            ;217
00003e  e7ec              B        |L2.26|
                  |L2.64|
000040  bf00              NOP                            ;214
000042  f7fffffe          BL       OS_CPU_SR_Save
000046  4680              MOV      r8,r0                 ;220
000048  4638              MOV      r0,r7                 ;221
00004a  f7fffffe          BL       OS_StrLen
00004e  4606              MOV      r6,r0                 ;221
000050  2e0f              CMP      r6,#0xf               ;222
000052  dd05              BLE      |L2.96|
000054  4640              MOV      r0,r8                 ;223
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  200b              MOVS     r0,#0xb               ;224
00005c  7020              STRB     r0,[r4,#0]            ;224
00005e  e7dc              B        |L2.26|
                  |L2.96|
000060  4639              MOV      r1,r7                 ;227
000062  f105000f          ADD      r0,r5,#0xf            ;227
000066  f7fffffe          BL       OS_StrCopy
00006a  4640              MOV      r0,r8                 ;228
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  2000              MOVS     r0,#0                 ;229
000072  7020              STRB     r0,[r4,#0]            ;229
000074  bf00              NOP      
000076  e7d0              B        |L2.26|
;;;231    #endif
                          ENDP

                  |L2.120|
                          DCD      OSIntNesting

                          AREA ||i.OSEventPendMulti||, CODE, READONLY, ALIGN=2

                  OSEventPendMulti PROC
;;;305    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;306    INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;307    {
000004  b083              SUB      sp,sp,#0xc
000006  4680              MOV      r8,r0
000008  460e              MOV      r6,r1
00000a  4615              MOV      r5,r2
00000c  9f10              LDR      r7,[sp,#0x40]
;;;308        OS_EVENT  **pevents;
;;;309        OS_EVENT   *pevent;
;;;310    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;311        OS_Q       *pq;
;;;312    #endif
;;;313        BOOLEAN     events_rdy;
;;;314        INT16U      events_rdy_nbr;
;;;315        INT8U       events_stat;
;;;316    #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
;;;317        OS_CPU_SR   cpu_sr = 0;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;318    #endif
;;;319    
;;;320    
;;;321    
;;;322    #if (OS_ARG_CHK_EN > 0)
;;;323        if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
;;;324            return (0);
;;;325        }
;;;326        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;327           *perr =  OS_ERR_PEVENT_NULL;
;;;328            return (0);
;;;329        }
;;;330        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;331           *perr =  OS_ERR_PEVENT_NULL;
;;;332            return (0);
;;;333        }
;;;334        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;335           *perr =  OS_ERR_PEVENT_NULL;
;;;336            return (0);
;;;337        }
;;;338    #endif
;;;339    
;;;340       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
000012  6030              STR      r0,[r6,#0]
;;;341    
;;;342        pevents     =  pevents_pend;
000014  46c1              MOV      r9,r8
;;;343        pevent      = *pevents;
000016  f8d94000          LDR      r4,[r9,#0]
;;;344        while  (pevent != (OS_EVENT *)0) {
00001a  e018              B        |L3.78|
                  |L3.28|
;;;345            switch (pevent->OSEventType) {                  /* Validate event block types                  */
00001c  7820              LDRB     r0,[r4,#0]
00001e  2801              CMP      r0,#1
000020  d007              BEQ      |L3.50|
000022  2803              CMP      r0,#3
000024  d004              BEQ      |L3.48|
000026  2804              CMP      r0,#4
000028  d005              BEQ      |L3.54|
00002a  2805              CMP      r0,#5
00002c  d102              BNE      |L3.52|
00002e  e003              B        |L3.56|
                  |L3.48|
;;;346    #if (OS_SEM_EN  > 0)
;;;347                case OS_EVENT_TYPE_SEM:
;;;348                     break;
000030  e008              B        |L3.68|
                  |L3.50|
;;;349    #endif
;;;350    #if (OS_MBOX_EN > 0)
;;;351                case OS_EVENT_TYPE_MBOX:
;;;352                     break;
000032  e007              B        |L3.68|
                  |L3.52|
;;;353    #endif
;;;354    #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
;;;355                case OS_EVENT_TYPE_Q:
;;;356                     break;
;;;357    #endif
;;;358    
;;;359                case OS_EVENT_TYPE_MUTEX:                                            
000034  bf00              NOP      
                  |L3.54|
;;;360                case OS_EVENT_TYPE_FLAG:
000036  bf00              NOP      
                  |L3.56|
;;;361                default:           
;;;362                    *perr = OS_ERR_EVENT_TYPE;
000038  2001              MOVS     r0,#1
00003a  7038              STRB     r0,[r7,#0]
;;;363                     return (0);
00003c  2000              MOVS     r0,#0
                  |L3.62|
;;;364            }
;;;365            pevents++;
;;;366            pevent = *pevents;
;;;367        }
;;;368    
;;;369        if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
;;;370           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;371            return (0);
;;;372        }
;;;373        if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
;;;374           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;375            return (0);
;;;376        }
;;;377    
;;;378    /*$PAGE*/
;;;379        OS_ENTER_CRITICAL();
;;;380        events_rdy     =  OS_FALSE;
;;;381        events_rdy_nbr =  0;
;;;382        events_stat    =  OS_STAT_RDY;
;;;383        pevents        =  pevents_pend;
;;;384        pevent         = *pevents;
;;;385        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;386            switch (pevent->OSEventType) {
;;;387    #if (OS_SEM_EN > 0)
;;;388                case OS_EVENT_TYPE_SEM:
;;;389                     if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
;;;390                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;391                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;392                          events_rdy   =  OS_TRUE;
;;;393                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;394                          events_rdy_nbr++;
;;;395    
;;;396                     } else {
;;;397                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;398                     }
;;;399                     break;
;;;400    #endif
;;;401    
;;;402    #if (OS_MBOX_EN > 0)
;;;403                case OS_EVENT_TYPE_MBOX:
;;;404                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;405                                                            /* ... return available message,           ... */
;;;406                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;407                         pevent->OSEventPtr  = (void *)0;
;;;408                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;409                          events_rdy         =  OS_TRUE;
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;419                case OS_EVENT_TYPE_Q:
;;;420                     pq = (OS_Q *)pevent->OSEventPtr;
;;;421                     if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
;;;422                                                            /* ... return available message,           ... */
;;;423                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;424                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;425                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;426                         }
;;;427                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;428                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;429                          events_rdy   = OS_TRUE;
;;;430                          events_rdy_nbr++;
;;;431    
;;;432                     } else {
;;;433                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;434                     }
;;;435                     break;
;;;436    #endif
;;;437    
;;;438                case OS_EVENT_TYPE_MUTEX:                                            
;;;439                case OS_EVENT_TYPE_FLAG:
;;;440                default:           
;;;441                     OS_EXIT_CRITICAL();
;;;442                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;443                    *perr        =  OS_ERR_EVENT_TYPE;
;;;444                     return (events_rdy_nbr);
;;;445            }
;;;446            pevents++;
;;;447            pevent = *pevents;
;;;448        }
;;;449    
;;;450        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;451           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;452            OS_EXIT_CRITICAL();
;;;453           *perr        =  OS_ERR_NONE;
;;;454            return (events_rdy_nbr);
;;;455        }
;;;456    /*$PAGE*/
;;;457                                                            /* Otherwise, must wait until any event occurs */
;;;458        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;459                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;460        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;461        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;462        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;463    
;;;464        OS_EXIT_CRITICAL();
;;;465        OS_Sched();                                         /* Find next highest priority task ready       */
;;;466        OS_ENTER_CRITICAL();
;;;467    
;;;468        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;469            case OS_STAT_PEND_OK:
;;;470            case OS_STAT_PEND_ABORT:
;;;471                 pevent = OSTCBCur->OSTCBEventPtr;
;;;472                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;473                    *pevents_rdy++ =  pevent;               /* ... return available event ...              */
;;;474                    *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
;;;475                      events_rdy_nbr++;
;;;476    
;;;477                 } else {                                   /* Else NO event available, handle as timeout  */
;;;478                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;479                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;480                 }
;;;481    			 break;
;;;482    
;;;483            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;484            default:                                        /* ... remove task from events' wait lists     */
;;;485                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;486                 break;
;;;487        }
;;;488    
;;;489        switch (OSTCBCur->OSTCBStatPend) {
;;;490            case OS_STAT_PEND_OK:
;;;491                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;492    #if (OS_SEM_EN > 0)
;;;493                     case OS_EVENT_TYPE_SEM:
;;;494                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;495                          break;
;;;496    #endif
;;;497    
;;;498    #if ((OS_MBOX_EN > 0) ||                 \
;;;499        ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
;;;500                     case OS_EVENT_TYPE_MBOX:
;;;501                     case OS_EVENT_TYPE_Q:
;;;502                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;503                          break;
;;;504    #endif
;;;505    
;;;506                     case OS_EVENT_TYPE_MUTEX:                                       
;;;507                     case OS_EVENT_TYPE_FLAG:
;;;508                     default:           
;;;509                          OS_EXIT_CRITICAL();
;;;510                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;511                         *perr        =  OS_ERR_EVENT_TYPE;
;;;512                          return (events_rdy_nbr);
;;;513                 }
;;;514                *perr = OS_ERR_NONE;
;;;515                 break;
;;;516    
;;;517            case OS_STAT_PEND_ABORT:
;;;518                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;519                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;520                 break;
;;;521                                                            
;;;522            case OS_STAT_PEND_TO:                                                
;;;523            default:        
;;;524                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;525                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;526                 break;
;;;527        }
;;;528    
;;;529        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;530        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;531        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;532        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;533        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;534        OS_EXIT_CRITICAL();
;;;535    
;;;536        return (events_rdy_nbr);
;;;537    }
00003e  b007              ADD      sp,sp,#0x1c
000040  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.68|
000044  bf00              NOP                            ;348
000046  f1090904          ADD      r9,r9,#4              ;365
00004a  f8d94000          LDR      r4,[r9,#0]            ;366
                  |L3.78|
00004e  2c00              CMP      r4,#0                 ;344
000050  d1e4              BNE      |L3.28|
000052  487e              LDR      r0,|L3.588|
000054  7800              LDRB     r0,[r0,#0]            ;369  ; OSIntNesting
000056  2800              CMP      r0,#0                 ;369
000058  dd03              BLE      |L3.98|
00005a  2002              MOVS     r0,#2                 ;370
00005c  7038              STRB     r0,[r7,#0]            ;370
00005e  2000              MOVS     r0,#0                 ;371
000060  e7ed              B        |L3.62|
                  |L3.98|
000062  487b              LDR      r0,|L3.592|
000064  7800              LDRB     r0,[r0,#0]            ;373  ; OSLockNesting
000066  2800              CMP      r0,#0                 ;373
000068  dd03              BLE      |L3.114|
00006a  200d              MOVS     r0,#0xd               ;374
00006c  7038              STRB     r0,[r7,#0]            ;374
00006e  2000              MOVS     r0,#0                 ;375
000070  e7e5              B        |L3.62|
                  |L3.114|
000072  f7fffffe          BL       OS_CPU_SR_Save
000076  9001              STR      r0,[sp,#4]            ;379
000078  2000              MOVS     r0,#0                 ;380
00007a  9002              STR      r0,[sp,#8]            ;380
00007c  4682              MOV      r10,r0                ;381
00007e  4683              MOV      r11,r0                ;382
000080  46c1              MOV      r9,r8                 ;383
000082  f8d94000          LDR      r4,[r9,#0]            ;384
000086  e03d              B        |L3.260|
                  |L3.136|
000088  7820              LDRB     r0,[r4,#0]            ;386
00008a  2801              CMP      r0,#1                 ;386
00008c  d019              BEQ      |L3.194|
00008e  2803              CMP      r0,#3                 ;386
000090  d004              BEQ      |L3.156|
000092  2804              CMP      r0,#4                 ;386
000094  d027              BEQ      |L3.230|
000096  2805              CMP      r0,#5                 ;386
000098  d124              BNE      |L3.228|
00009a  e025              B        |L3.232|
                  |L3.156|
00009c  8920              LDRH     r0,[r4,#8]            ;389
00009e  2800              CMP      r0,#0                 ;389
0000a0  dd0c              BLE      |L3.188|
0000a2  8920              LDRH     r0,[r4,#8]            ;390
0000a4  1e40              SUBS     r0,r0,#1              ;390
0000a6  8120              STRH     r0,[r4,#8]            ;390
0000a8  c610              STM      r6!,{r4}              ;391
0000aa  2001              MOVS     r0,#1                 ;392
0000ac  9002              STR      r0,[sp,#8]            ;392
0000ae  2000              MOVS     r0,#0                 ;393
0000b0  c501              STM      r5!,{r0}              ;393
0000b2  f10a0001          ADD      r0,r10,#1             ;394
0000b6  fa1ffa80          UXTH     r10,r0                ;394
0000ba  e001              B        |L3.192|
                  |L3.188|
0000bc  f04b0b01          ORR      r11,r11,#1            ;397
                  |L3.192|
0000c0  e01b              B        |L3.250|
                  |L3.194|
0000c2  6860              LDR      r0,[r4,#4]            ;404
0000c4  b158              CBZ      r0,|L3.222|
0000c6  6860              LDR      r0,[r4,#4]            ;406
0000c8  c501              STM      r5!,{r0}              ;406
0000ca  2000              MOVS     r0,#0                 ;407
0000cc  6060              STR      r0,[r4,#4]            ;407
0000ce  c610              STM      r6!,{r4}              ;408
0000d0  2001              MOVS     r0,#1                 ;409
0000d2  9002              STR      r0,[sp,#8]            ;409
0000d4  f10a0001          ADD      r0,r10,#1             ;410
0000d8  fa1ffa80          UXTH     r10,r0                ;410
0000dc  e001              B        |L3.226|
                  |L3.222|
0000de  f04b0b02          ORR      r11,r11,#2            ;413
                  |L3.226|
0000e2  e00a              B        |L3.250|
                  |L3.228|
0000e4  bf00              NOP                            ;438
                  |L3.230|
0000e6  bf00              NOP                            ;439
                  |L3.232|
0000e8  9801              LDR      r0,[sp,#4]            ;441
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2000              MOVS     r0,#0                 ;442
0000f0  6030              STR      r0,[r6,#0]            ;442
0000f2  2001              MOVS     r0,#1                 ;443
0000f4  7038              STRB     r0,[r7,#0]            ;443
0000f6  4650              MOV      r0,r10                ;444
0000f8  e7a1              B        |L3.62|
                  |L3.250|
0000fa  bf00              NOP                            ;399
0000fc  f1090904          ADD      r9,r9,#4              ;446
000100  f8d94000          LDR      r4,[r9,#0]            ;447
                  |L3.260|
000104  2c00              CMP      r4,#0                 ;385
000106  d1bf              BNE      |L3.136|
000108  9802              LDR      r0,[sp,#8]            ;450
00010a  2801              CMP      r0,#1                 ;450
00010c  d108              BNE      |L3.288|
00010e  2000              MOVS     r0,#0                 ;451
000110  6030              STR      r0,[r6,#0]            ;451
000112  9801              LDR      r0,[sp,#4]            ;452
000114  f7fffffe          BL       OS_CPU_SR_Restore
000118  2000              MOVS     r0,#0                 ;453
00011a  7038              STRB     r0,[r7,#0]            ;453
00011c  4650              MOV      r0,r10                ;454
00011e  e78e              B        |L3.62|
                  |L3.288|
000120  484c              LDR      r0,|L3.596|
000122  6800              LDR      r0,[r0,#0]            ;458  ; OSTCBCur
000124  f8900030          LDRB     r0,[r0,#0x30]         ;458
000128  f04b0180          ORR      r1,r11,#0x80          ;458
00012c  4308              ORRS     r0,r0,r1              ;458
00012e  4949              LDR      r1,|L3.596|
000130  6809              LDR      r1,[r1,#0]            ;458  ; OSTCBCur
000132  f8810030          STRB     r0,[r1,#0x30]         ;458
000136  2000              MOVS     r0,#0                 ;460
000138  4946              LDR      r1,|L3.596|
00013a  6809              LDR      r1,[r1,#0]            ;460  ; OSTCBCur
00013c  f8810031          STRB     r0,[r1,#0x31]         ;460
000140  4944              LDR      r1,|L3.596|
000142  9806              LDR      r0,[sp,#0x18]         ;461
000144  6809              LDR      r1,[r1,#0]            ;461  ; OSTCBCur
000146  85c8              STRH     r0,[r1,#0x2e]         ;461
000148  4640              MOV      r0,r8                 ;462
00014a  f7fffffe          BL       OS_EventTaskWaitMulti
00014e  9801              LDR      r0,[sp,#4]            ;464
000150  f7fffffe          BL       OS_CPU_SR_Restore
000154  f7fffffe          BL       OS_Sched
000158  f7fffffe          BL       OS_CPU_SR_Save
00015c  9001              STR      r0,[sp,#4]            ;466
00015e  483d              LDR      r0,|L3.596|
000160  6800              LDR      r0,[r0,#0]            ;468  ; OSTCBCur
000162  f8900031          LDRB     r0,[r0,#0x31]         ;468
000166  b120              CBZ      r0,|L3.370|
000168  2801              CMP      r0,#1                 ;468
00016a  d01b              BEQ      |L3.420|
00016c  2802              CMP      r0,#2                 ;468
00016e  d118              BNE      |L3.418|
000170  e000              B        |L3.372|
                  |L3.370|
000172  bf00              NOP                            ;470
                  |L3.372|
000174  4837              LDR      r0,|L3.596|
000176  6800              LDR      r0,[r0,#0]            ;471  ; OSTCBCur
000178  69c4              LDR      r4,[r0,#0x1c]         ;471
00017a  b13c              CBZ      r4,|L3.396|
00017c  c610              STM      r6!,{r4}              ;473
00017e  2000              MOVS     r0,#0                 ;474
000180  6030              STR      r0,[r6,#0]            ;474
000182  f10a0001          ADD      r0,r10,#1             ;475
000186  fa1ffa80          UXTH     r10,r0                ;475
00018a  e009              B        |L3.416|
                  |L3.396|
00018c  2001              MOVS     r0,#1                 ;478
00018e  4931              LDR      r1,|L3.596|
000190  6809              LDR      r1,[r1,#0]            ;478  ; OSTCBCur
000192  f8810031          STRB     r0,[r1,#0x31]         ;478
000196  4641              MOV      r1,r8                 ;479
000198  482e              LDR      r0,|L3.596|
00019a  6800              LDR      r0,[r0,#0]            ;479  ; OSTCBCur
00019c  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L3.416|
0001a0  e006              B        |L3.432|
                  |L3.418|
0001a2  bf00              NOP                            ;483
                  |L3.420|
0001a4  4641              MOV      r1,r8                 ;485
0001a6  482b              LDR      r0,|L3.596|
0001a8  6800              LDR      r0,[r0,#0]            ;485  ; OSTCBCur
0001aa  f7fffffe          BL       OS_EventTaskRemoveMulti
0001ae  bf00              NOP                            ;486
                  |L3.432|
0001b0  bf00              NOP                            ;481
0001b2  4828              LDR      r0,|L3.596|
0001b4  6800              LDR      r0,[r0,#0]            ;489  ; OSTCBCur
0001b6  f8900031          LDRB     r0,[r0,#0x31]         ;489
0001ba  b120              CBZ      r0,|L3.454|
0001bc  2801              CMP      r0,#1                 ;489
0001be  d028              BEQ      |L3.530|
0001c0  2802              CMP      r0,#2                 ;489
0001c2  d125              BNE      |L3.528|
0001c4  e01f              B        |L3.518|
                  |L3.454|
0001c6  7820              LDRB     r0,[r4,#0]            ;491
0001c8  2806              CMP      r0,#6                 ;491
0001ca  d20d              BCS      |L3.488|
0001cc  e8dff000          TBB      [pc,r0]               ;491
0001d0  0c060703          DCB      0x0c,0x06,0x07,0x03
0001d4  0d0e              DCB      0x0d,0x0e
0001d6  2000              MOVS     r0,#0                 ;494
0001d8  c501              STM      r5!,{r0}              ;494
0001da  e010              B        |L3.510|
0001dc  bf00              NOP                            ;501
0001de  481d              LDR      r0,|L3.596|
0001e0  6800              LDR      r0,[r0,#0]            ;502  ; OSTCBCur
0001e2  6a40              LDR      r0,[r0,#0x24]         ;502
0001e4  c501              STM      r5!,{r0}              ;502
0001e6  e00a              B        |L3.510|
                  |L3.488|
0001e8  bf00              NOP                            ;506
0001ea  bf00              NOP                            ;507
0001ec  9801              LDR      r0,[sp,#4]            ;509
0001ee  f7fffffe          BL       OS_CPU_SR_Restore
0001f2  2000              MOVS     r0,#0                 ;510
0001f4  6030              STR      r0,[r6,#0]            ;510
0001f6  2001              MOVS     r0,#1                 ;511
0001f8  7038              STRB     r0,[r7,#0]            ;511
0001fa  4650              MOV      r0,r10                ;512
0001fc  e71f              B        |L3.62|
                  |L3.510|
0001fe  bf00              NOP                            ;495
000200  2000              MOVS     r0,#0                 ;514
000202  7038              STRB     r0,[r7,#0]            ;514
000204  e00a              B        |L3.540|
                  |L3.518|
000206  2000              MOVS     r0,#0                 ;518
000208  c501              STM      r5!,{r0}              ;518
00020a  200e              MOVS     r0,#0xe               ;519
00020c  7038              STRB     r0,[r7,#0]            ;519
00020e  e005              B        |L3.540|
                  |L3.528|
000210  bf00              NOP                            ;522
                  |L3.530|
000212  2000              MOVS     r0,#0                 ;524
000214  c501              STM      r5!,{r0}              ;524
000216  200a              MOVS     r0,#0xa               ;525
000218  7038              STRB     r0,[r7,#0]            ;525
00021a  bf00              NOP                            ;526
                  |L3.540|
00021c  bf00              NOP                            ;515
00021e  2000              MOVS     r0,#0                 ;529
000220  490c              LDR      r1,|L3.596|
000222  6809              LDR      r1,[r1,#0]            ;529  ; OSTCBCur
000224  f8810030          STRB     r0,[r1,#0x30]         ;529
000228  490a              LDR      r1,|L3.596|
00022a  6809              LDR      r1,[r1,#0]            ;530  ; OSTCBCur
00022c  f8810031          STRB     r0,[r1,#0x31]         ;530
000230  4908              LDR      r1,|L3.596|
000232  6809              LDR      r1,[r1,#0]            ;531  ; OSTCBCur
000234  61c8              STR      r0,[r1,#0x1c]         ;531
000236  4907              LDR      r1,|L3.596|
000238  6809              LDR      r1,[r1,#0]            ;532  ; OSTCBCur
00023a  6208              STR      r0,[r1,#0x20]         ;532
00023c  4905              LDR      r1,|L3.596|
00023e  6809              LDR      r1,[r1,#0]            ;533  ; OSTCBCur
000240  6248              STR      r0,[r1,#0x24]         ;533
000242  9801              LDR      r0,[sp,#4]            ;534
000244  f7fffffe          BL       OS_CPU_SR_Restore
000248  4650              MOV      r0,r10                ;536
00024a  e6f8              B        |L3.62|
;;;538    #endif
                          ENDP

                  |L3.588|
                          DCD      OSIntNesting
                  |L3.592|
                          DCD      OSLockNesting
                  |L3.596|
                          DCD      OSTCBCur

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00001a  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
00001e  f7fffffe          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
000022  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
000026  f7fffffe          BL       OSDebugInit
;;;591    #endif
;;;592    }
00002a  bd10              POP      {r4,pc}
;;;593    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
000000  4806              LDR      r0,|L5.28|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L5.26|
;;;622            if (OSIntNesting < 255u) {
000008  4805              LDR      r0,|L5.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L5.26|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
000010  4803              LDR      r0,|L5.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L5.32|
000018  7008              STRB     r0,[r1,#0]
                  |L5.26|
;;;624            }
;;;625        }
;;;626    }
00001a  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  |L5.28|
                          DCD      OSRunning
                  |L5.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
000004  481a              LDR      r0,|L6.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L6.110|
;;;656            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L6.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  2800              CMP      r0,#0
000018  dd04              BLE      |L6.36|
;;;658                OSIntNesting--;
00001a  4816              LDR      r0,|L6.116|
00001c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001e  1e40              SUBS     r0,r0,#1
000020  4914              LDR      r1,|L6.116|
000022  7008              STRB     r0,[r1,#0]
                  |L6.36|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
000024  4813              LDR      r0,|L6.116|
000026  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000028  b9f0              CBNZ     r0,|L6.104|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
00002a  4813              LDR      r0,|L6.120|
00002c  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002e  b9d8              CBNZ     r0,|L6.104|
;;;662                    OS_SchedNew();
000030  f7fffffe          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000034  4811              LDR      r0,|L6.124|
000036  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000038  4911              LDR      r1,|L6.128|
00003a  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
00003c  4288              CMP      r0,r1
00003e  d013              BEQ      |L6.104|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
000040  4810              LDR      r0,|L6.132|
000042  490e              LDR      r1,|L6.124|
000044  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000046  f8500021          LDR      r0,[r0,r1,LSL #2]
00004a  490f              LDR      r1,|L6.136|
00004c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004e  4608              MOV      r0,r1
000050  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000052  6b80              LDR      r0,[r0,#0x38]
000054  1c40              ADDS     r0,r0,#1
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  6388              STR      r0,[r1,#0x38]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L6.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L6.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L6.104|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L6.110|
;;;674        }
;;;675    }
00006e  bd10              POP      {r4,pc}
;;;676    /*$PAGE*/
                          ENDP

                  |L6.112|
                          DCD      OSRunning
                  |L6.116|
                          DCD      OSIntNesting
                  |L6.120|
                          DCD      OSLockNesting
                  |L6.124|
                          DCD      OSPrioHighRdy
                  |L6.128|
                          DCD      OSPrioCur
                  |L6.132|
                          DCD      OSTCBPrioTbl
                  |L6.136|
                          DCD      OSTCBHighRdy
                  |L6.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;693    #if OS_SCHED_LOCK_EN > 0
;;;694    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;695    {
;;;696    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;697        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;698    #endif
;;;699    
;;;700    
;;;701    
;;;702        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000004  480b              LDR      r0,|L7.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L7.48|
;;;703            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;704            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
000012  4809              LDR      r0,|L7.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L7.42|
;;;705                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000018  4808              LDR      r0,|L7.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L7.42|
;;;706                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L7.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L7.60|
000028  7008              STRB     r0,[r1,#0]
                  |L7.42|
;;;707                }
;;;708            }
;;;709            OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L7.48|
;;;710        }
;;;711    }
000030  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      OSRunning
                  |L7.56|
                          DCD      OSIntNesting
                  |L7.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;730    #if OS_SCHED_LOCK_EN > 0
;;;731    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;732    {
;;;733    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;734        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;735    #endif
;;;736    
;;;737    
;;;738    
;;;739        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L8.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d122              BNE      |L8.82|
;;;740            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;741            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
000012  4811              LDR      r0,|L8.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000016  2800              CMP      r0,#0
000018  dd18              BLE      |L8.76|
;;;742                OSLockNesting--;                               /* Decrement lock nesting level             */
00001a  480f              LDR      r0,|L8.88|
00001c  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001e  1e40              SUBS     r0,r0,#1
000020  490d              LDR      r1,|L8.88|
000022  7008              STRB     r0,[r1,#0]
;;;743                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000028  b960              CBNZ     r0,|L8.68|
;;;744                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
00002a  480c              LDR      r0,|L8.92|
00002c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002e  b928              CBNZ     r0,|L8.60|
;;;745                        OS_EXIT_CRITICAL();
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       OS_CPU_SR_Restore
;;;746                        OS_Sched();                            /* See if a HPT is ready                    */
000036  f7fffffe          BL       OS_Sched
00003a  e00a              B        |L8.82|
                  |L8.60|
;;;747                    } else {
;;;748                        OS_EXIT_CRITICAL();
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  e006              B        |L8.82|
                  |L8.68|
;;;749                    }
;;;750                } else {
;;;751                    OS_EXIT_CRITICAL();
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  e002              B        |L8.82|
                  |L8.76|
;;;752                }
;;;753            } else {
;;;754                OS_EXIT_CRITICAL();
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       OS_CPU_SR_Restore
                  |L8.82|
;;;755            }
;;;756        }
;;;757    }
000052  bd10              POP      {r4,pc}
;;;758    #endif
                          ENDP

                  |L8.84|
                          DCD      OSRunning
                  |L8.88|
                          DCD      OSLockNesting
                  |L8.92|
                          DCD      OSIntNesting

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;780    
;;;781    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;782    {
;;;783        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L9.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L9.46|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L9.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L9.56|
000012  7008              STRB     r0,[r1,#0]
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L9.60|
000016  4907              LDR      r1,|L9.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L9.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L9.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L9.46|
;;;789        }
;;;790    }
00002e  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  |L9.48|
                          DCD      OSRunning
                  |L9.52|
                          DCD      OSPrioHighRdy
                  |L9.56|
                          DCD      OSPrioCur
                  |L9.60|
                          DCD      OSTCBPrioTbl
                  |L9.64|
                          DCD      OSTCBHighRdy
                  |L9.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;812    #if OS_TASK_STAT_EN > 0
;;;813    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;814    {
;;;815    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;816        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;817    #endif
;;;818    
;;;819    
;;;820    
;;;821        OSTimeDly(2);                                /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;822        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;823        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L10.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;824        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;825        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
00001c  2064              MOVS     r0,#0x64
00001e  f7fffffe          BL       OSTimeDly
;;;826        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;827        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L10.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L10.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;828        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L10.72|
000034  7008              STRB     r0,[r1,#0]
;;;829        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;830    }
00003c  bd10              POP      {r4,pc}
;;;831    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L10.64|
                          DCD      OSIdleCtr
                  |L10.68|
                          DCD      OSIdleCtrMax
                  |L10.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;846    
;;;847    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;848    {
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
000002  2600              MOVS     r6,#0
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
000004  f7fffffe          BL       OSTimeTickHook
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;864        OSTime++;
00000e  4831              LDR      r0,|L11.212|
000010  6800              LDR      r0,[r0,#0]  ; OSTime
000012  1c40              ADDS     r0,r0,#1
000014  492f              LDR      r1,|L11.212|
000016  6008              STR      r0,[r1,#0]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
00001e  482e              LDR      r0,|L11.216|
000020  7800              LDRB     r0,[r0,#0]  ; OSRunning
000022  2801              CMP      r0,#1
000024  d153              BNE      |L11.206|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000026  482d              LDR      r0,|L11.220|
000028  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
00002a  b120              CBZ      r0,|L11.54|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L11.58|
000030  2802              CMP      r0,#2
000032  d109              BNE      |L11.72|
000034  e003              B        |L11.62|
                  |L11.54|
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
000036  2501              MOVS     r5,#1
;;;872                     break;
000038  e00b              B        |L11.82|
                  |L11.58|
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
00003a  2500              MOVS     r5,#0
;;;876                     break;
00003c  e009              B        |L11.82|
                  |L11.62|
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
00003e  2501              MOVS     r5,#1
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
000040  2001              MOVS     r0,#1
000042  4926              LDR      r1,|L11.220|
000044  7008              STRB     r0,[r1,#0]
;;;881                     break;
000046  e004              B        |L11.82|
                  |L11.72|
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
000048  2501              MOVS     r5,#1
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
00004a  2000              MOVS     r0,#0
00004c  4923              LDR      r1,|L11.220|
00004e  7008              STRB     r0,[r1,#0]
;;;886                     break;
000050  bf00              NOP      
                  |L11.82|
000052  bf00              NOP                            ;872
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000054  b905              CBNZ     r5,|L11.88|
                  |L11.86|
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;894                OS_ENTER_CRITICAL();
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;912                OS_EXIT_CRITICAL();
;;;913            }
;;;914        }
;;;915    }
000056  bd70              POP      {r4-r6,pc}
                  |L11.88|
000058  4821              LDR      r0,|L11.224|
00005a  6804              LDR      r4,[r0,#0]            ;892  ; OSTCBList
00005c  e033              B        |L11.198|
                  |L11.94|
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4606              MOV      r6,r0                 ;894
000064  8de0              LDRH     r0,[r4,#0x2e]         ;895
000066  b350              CBZ      r0,|L11.190|
000068  8de0              LDRH     r0,[r4,#0x2e]         ;896
00006a  1e40              SUBS     r0,r0,#1              ;896
00006c  b280              UXTH     r0,r0                 ;896
00006e  85e0              STRH     r0,[r4,#0x2e]         ;896
000070  bb28              CBNZ     r0,|L11.190|
000072  f8940030          LDRB     r0,[r4,#0x30]         ;898
000076  f0000037          AND      r0,r0,#0x37           ;898
00007a  b140              CBZ      r0,|L11.142|
00007c  f8140f30          LDRB     r0,[r4,#0x30]!        ;899
000080  f0200037          BIC      r0,r0,#0x37           ;899
000084  7020              STRB     r0,[r4,#0]            ;899
000086  2001              MOVS     r0,#1                 ;900
000088  7060              STRB     r0,[r4,#1]            ;900
00008a  3c30              SUBS     r4,r4,#0x30           ;900
00008c  e002              B        |L11.148|
                  |L11.142|
00008e  2000              MOVS     r0,#0                 ;902
000090  f8840031          STRB     r0,[r4,#0x31]         ;902
                  |L11.148|
000094  f8940030          LDRB     r0,[r4,#0x30]         ;905
000098  f0000008          AND      r0,r0,#8              ;905
00009c  b978              CBNZ     r0,|L11.190|
00009e  3434              ADDS     r4,r4,#0x34           ;906
0000a0  78a0              LDRB     r0,[r4,#2]            ;906
0000a2  4910              LDR      r1,|L11.228|
0000a4  7809              LDRB     r1,[r1,#0]            ;906  ; OSRdyGrp
0000a6  4308              ORRS     r0,r0,r1              ;906
0000a8  490e              LDR      r1,|L11.228|
0000aa  7008              STRB     r0,[r1,#0]            ;906
0000ac  7820              LDRB     r0,[r4,#0]            ;907
0000ae  490e              LDR      r1,|L11.232|
0000b0  5c08              LDRB     r0,[r1,r0]            ;907
0000b2  7861              LDRB     r1,[r4,#1]            ;907
0000b4  4308              ORRS     r0,r0,r1              ;907
0000b6  f8141934          LDRB     r1,[r4],#-0x34        ;907
0000ba  4a0b              LDR      r2,|L11.232|
0000bc  5450              STRB     r0,[r2,r1]            ;907
                  |L11.190|
0000be  6964              LDR      r4,[r4,#0x14]         ;911
0000c0  4630              MOV      r0,r6                 ;912
0000c2  f7fffffe          BL       OS_CPU_SR_Restore
                  |L11.198|
0000c6  f8940032          LDRB     r0,[r4,#0x32]         ;893
0000ca  281f              CMP      r0,#0x1f              ;893
0000cc  d1c7              BNE      |L11.94|
                  |L11.206|
0000ce  bf00              NOP      
0000d0  e7c1              B        |L11.86|
;;;916    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L11.212|
                          DCD      OSTime
                  |L11.216|
                          DCD      OSRunning
                  |L11.220|
                          DCD      OSTickStepState
                  |L11.224|
                          DCD      OSTCBList
                  |L11.228|
                          DCD      OSRdyGrp
                  |L11.232|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;931    
;;;932    INT16U  OSVersion (void)
000000  f44f708f          MOV      r0,#0x11e
;;;933    {
;;;934        return (OS_VERSION);
;;;935    }
000004  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;950    #if OS_TASK_DEL_EN > 0
;;;951    void  OS_Dummy (void)
000000  4770              BX       lr
;;;952    {
;;;953    }
;;;954    #endif
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;984    #if (OS_EVENT_EN)
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;986    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000c  7aa8              LDRB     r0,[r5,#0xa]
00000e  491c              LDR      r1,|L14.128|
000010  5c0e              LDRB     r6,[r1,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000012  f105000b          ADD      r0,r5,#0xb
000016  5d80              LDRB     r0,[r0,r6]
000018  f811b000          LDRB     r11,[r1,r0]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
00001c  eb0b00c6          ADD      r0,r11,r6,LSL #3
000020  f0000aff          AND      r10,r0,#0xff
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000024  4817              LDR      r0,|L14.132|
000026  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
00002a  2000              MOVS     r0,#0
00002c  3424              ADDS     r4,r4,#0x24
00002e  8160              STRH     r0,[r4,#0xa]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000030  6027              STR      r7,[r4,#0]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
000032  7b20              LDRB     r0,[r4,#0xc]
000034  ea200008          BIC      r0,r0,r8
000038  7320              STRB     r0,[r4,#0xc]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00003a  f884900d          STRB     r9,[r4,#0xd]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00003e  7b20              LDRB     r0,[r4,#0xc]
000040  3c24              SUBS     r4,r4,#0x24
000042  f0000008          AND      r0,r0,#8
000046  b968              CBNZ     r0,|L14.100|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  490e              LDR      r1,|L14.136|
00004e  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000050  4308              ORRS     r0,r0,r1
000052  490d              LDR      r1,|L14.136|
000054  7008              STRB     r0,[r1,#0]
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000056  480d              LDR      r0,|L14.140|
000058  5d80              LDRB     r0,[r0,r6]
00005a  f8941035          LDRB     r1,[r4,#0x35]
00005e  4308              ORRS     r0,r0,r1
000060  490a              LDR      r1,|L14.140|
000062  5588              STRB     r0,[r1,r6]
                  |L14.100|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
00006c  6a20              LDR      r0,[r4,#0x20]
00006e  b120              CBZ      r0,|L14.122|
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000070  4620              MOV      r0,r4
000072  6a21              LDR      r1,[r4,#0x20]
000074  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000078  61e5              STR      r5,[r4,#0x1c]
                  |L14.122|
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
00007a  4650              MOV      r0,r10
;;;1039   }
00007c  e8bd8ff0          POP      {r4-r11,pc}
;;;1040   #endif
                          ENDP

                  |L14.128|
                          DCD      OSUnMapTbl
                  |L14.132|
                          DCD      OSTCBPrioTbl
                  |L14.136|
                          DCD      OSRdyGrp
                  |L14.140|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1133   #if (OS_EVENT_EN)
;;;1134   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1135                             OS_EVENT *pevent)
;;;1136   {
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
000002  f8902034          LDRB     r2,[r0,#0x34]
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
000006  f101030b          ADD      r3,r1,#0xb
00000a  5c9b              LDRB     r3,[r3,r2]
00000c  f8904035          LDRB     r4,[r0,#0x35]
000010  43a3              BICS     r3,r3,r4
000012  f101040b          ADD      r4,r1,#0xb
000016  54a3              STRB     r3,[r4,r2]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
000018  4623              MOV      r3,r4
00001a  5c9b              LDRB     r3,[r3,r2]
00001c  b923              CBNZ     r3,|L15.40|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
00001e  7a8b              LDRB     r3,[r1,#0xa]
000020  f8904036          LDRB     r4,[r0,#0x36]
000024  43a3              BICS     r3,r3,r4
000026  728b              STRB     r3,[r1,#0xa]
                  |L15.40|
;;;1144       }
;;;1145   }
000028  bd10              POP      {r4,pc}
;;;1146   #endif
                          ENDP


                          AREA ||i.OS_EventTaskRemoveMulti||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemoveMulti PROC
;;;1163   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1164   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1165                                  OS_EVENT **pevents_multi)
;;;1166   {
000002  4602              MOV      r2,r0
;;;1167       OS_EVENT **pevents;
;;;1168       OS_EVENT  *pevent;
;;;1169       INT8U      y;
;;;1170   #if (OS_LOWEST_PRIO <= 63)
;;;1171       INT8U      bity;
;;;1172       INT8U      bitx;
;;;1173   #else
;;;1174       INT16U     bity;
;;;1175       INT16U     bitx;
;;;1176   #endif
;;;1177   
;;;1178   
;;;1179       y       =  ptcb->OSTCBY;
000004  f8124f34          LDRB     r4,[r2,#0x34]!
;;;1180       bity    =  ptcb->OSTCBBitY;
000008  7895              LDRB     r5,[r2,#2]
;;;1181       bitx    =  ptcb->OSTCBBitX;
00000a  7856              LDRB     r6,[r2,#1]
00000c  3a34              SUBS     r2,r2,#0x34
;;;1182       pevents =  pevents_multi;
00000e  460b              MOV      r3,r1
;;;1183       pevent  = *pevents;
000010  6818              LDR      r0,[r3,#0]
;;;1184       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
000012  e00f              B        |L16.52|
                  |L16.20|
;;;1185           pevent->OSEventTbl[y]  &= ~bitx;
000014  f100070b          ADD      r7,r0,#0xb
000018  5d3f              LDRB     r7,[r7,r4]
00001a  43b7              BICS     r7,r7,r6
00001c  f1000c0b          ADD      r12,r0,#0xb
000020  f80c7004          STRB     r7,[r12,r4]
;;;1186           if (pevent->OSEventTbl[y] == 0) {
000024  4667              MOV      r7,r12
000026  5d3f              LDRB     r7,[r7,r4]
000028  b917              CBNZ     r7,|L16.48|
;;;1187               pevent->OSEventGrp &= ~bity;
00002a  7a87              LDRB     r7,[r0,#0xa]
00002c  43af              BICS     r7,r7,r5
00002e  7287              STRB     r7,[r0,#0xa]
                  |L16.48|
;;;1188           }
;;;1189           pevents++;
000030  1d1b              ADDS     r3,r3,#4
;;;1190           pevent = *pevents;
000032  6818              LDR      r0,[r3,#0]
                  |L16.52|
000034  2800              CMP      r0,#0                 ;1184
000036  d1ed              BNE      |L16.20|
;;;1191       }
;;;1192   }
000038  bdf0              POP      {r4-r7,pc}
;;;1193   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1056   #if (OS_EVENT_EN)
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;1058   {
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4a1b              LDR      r2,|L17.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000008  4a19              LDR      r2,|L17.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8923034          LDRB     r3,[r2,#0x34]
000010  f100020b          ADD      r2,r0,#0xb
000014  5cd2              LDRB     r2,[r2,r3]
000016  4b16              LDR      r3,|L17.112|
000018  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00001a  f8933035          LDRB     r3,[r3,#0x35]
00001e  431a              ORRS     r2,r2,r3
000020  4b13              LDR      r3,|L17.112|
000022  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000024  f8934034          LDRB     r4,[r3,#0x34]
000028  f100030b          ADD      r3,r0,#0xb
00002c  551a              STRB     r2,[r3,r4]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00002e  7a82              LDRB     r2,[r0,#0xa]
000030  4b0f              LDR      r3,|L17.112|
000032  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000034  f8933036          LDRB     r3,[r3,#0x36]
000038  431a              ORRS     r2,r2,r3
00003a  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00003c  4a0c              LDR      r2,|L17.112|
00003e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000040  f8921034          LDRB     r1,[r2,#0x34]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
000044  4a0b              LDR      r2,|L17.116|
000046  5c52              LDRB     r2,[r2,r1]
000048  4b09              LDR      r3,|L17.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933035          LDRB     r3,[r3,#0x35]
000050  439a              BICS     r2,r2,r3
000052  4b08              LDR      r3,|L17.116|
000054  545a              STRB     r2,[r3,r1]
;;;1069       if (OSRdyTbl[y] == 0) {
000056  461a              MOV      r2,r3
000058  5c52              LDRB     r2,[r2,r1]
00005a  b942              CBNZ     r2,|L17.110|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
00005c  4a04              LDR      r2,|L17.112|
00005e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000060  f8923036          LDRB     r3,[r2,#0x36]
000064  4a04              LDR      r2,|L17.120|
000066  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000068  439a              BICS     r2,r2,r3
00006a  4b03              LDR      r3,|L17.120|
00006c  701a              STRB     r2,[r3,#0]
                  |L17.110|
;;;1071       }
;;;1072   }
00006e  bd10              POP      {r4,pc}
;;;1073   #endif
                          ENDP

                  |L17.112|
                          DCD      OSTCBCur
                  |L17.116|
                          DCD      OSRdyTbl
                  |L17.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventTaskWaitMulti||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWaitMulti PROC
;;;1090   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1091   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
000000  b570              PUSH     {r4-r6,lr}
;;;1092   {
000002  4601              MOV      r1,r0
;;;1093       OS_EVENT **pevents;
;;;1094       OS_EVENT  *pevent;
;;;1095       INT8U      y;
;;;1096   
;;;1097   
;;;1098       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000004  2400              MOVS     r4,#0
000006  4d20              LDR      r5,|L18.136|
000008  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00000a  61ec              STR      r4,[r5,#0x1c]
;;;1099       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00000c  4c1e              LDR      r4,|L18.136|
00000e  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000010  6221              STR      r1,[r4,#0x20]
;;;1100   
;;;1101       pevents =  pevents_wait;
000012  460b              MOV      r3,r1
;;;1102       pevent  = *pevents;
000014  6818              LDR      r0,[r3,#0]
;;;1103       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
000016  e01b              B        |L18.80|
                  |L18.24|
;;;1104           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000018  4c1b              LDR      r4,|L18.136|
00001a  6824              LDR      r4,[r4,#0]  ; OSTCBCur
00001c  f8945034          LDRB     r5,[r4,#0x34]
000020  f100040b          ADD      r4,r0,#0xb
000024  5d64              LDRB     r4,[r4,r5]
000026  4d18              LDR      r5,|L18.136|
000028  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00002a  f8955035          LDRB     r5,[r5,#0x35]
00002e  432c              ORRS     r4,r4,r5
000030  4d15              LDR      r5,|L18.136|
000032  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000034  f8956034          LDRB     r6,[r5,#0x34]
000038  f100050b          ADD      r5,r0,#0xb
00003c  55ac              STRB     r4,[r5,r6]
;;;1105           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00003e  7a84              LDRB     r4,[r0,#0xa]
000040  4d11              LDR      r5,|L18.136|
000042  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000044  f8955036          LDRB     r5,[r5,#0x36]
000048  432c              ORRS     r4,r4,r5
00004a  7284              STRB     r4,[r0,#0xa]
;;;1106           pevents++;
00004c  1d1b              ADDS     r3,r3,#4
;;;1107           pevent = *pevents;
00004e  6818              LDR      r0,[r3,#0]
                  |L18.80|
000050  2800              CMP      r0,#0                 ;1103
000052  d1e1              BNE      |L18.24|
;;;1108       }
;;;1109   
;;;1110       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000054  4c0c              LDR      r4,|L18.136|
000056  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000058  f8942034          LDRB     r2,[r4,#0x34]
;;;1111       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
00005c  4c0b              LDR      r4,|L18.140|
00005e  5ca4              LDRB     r4,[r4,r2]
000060  4d09              LDR      r5,|L18.136|
000062  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000064  f8955035          LDRB     r5,[r5,#0x35]
000068  43ac              BICS     r4,r4,r5
00006a  4d08              LDR      r5,|L18.140|
00006c  54ac              STRB     r4,[r5,r2]
;;;1112       if (OSRdyTbl[y] == 0) {
00006e  462c              MOV      r4,r5
000070  5ca4              LDRB     r4,[r4,r2]
000072  b944              CBNZ     r4,|L18.134|
;;;1113           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
000074  4c04              LDR      r4,|L18.136|
000076  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000078  f8945036          LDRB     r5,[r4,#0x36]
00007c  4c04              LDR      r4,|L18.144|
00007e  7824              LDRB     r4,[r4,#0]  ; OSRdyGrp
000080  43ac              BICS     r4,r4,r5
000082  4d03              LDR      r5,|L18.144|
000084  702c              STRB     r4,[r5,#0]
                  |L18.134|
;;;1114       }
;;;1115   }
000086  bd70              POP      {r4-r6,pc}
;;;1116   #endif
                          ENDP

                  |L18.136|
                          DCD      OSTCBCur
                  |L18.140|
                          DCD      OSRdyTbl
                  |L18.144|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1208   #if (OS_EVENT_EN)
;;;1209   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  2300              MOVS     r3,#0
;;;1210   {
;;;1211   #if OS_LOWEST_PRIO <= 63
;;;1212       INT8U  *ptbl;
;;;1213   #else
;;;1214       INT16U *ptbl;
;;;1215   #endif
;;;1216       INT8U   i;
;;;1217   
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000002  7283              STRB     r3,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
000004  f100010b          ADD      r1,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
000008  2200              MOVS     r2,#0
00000a  e004              B        |L19.22|
                  |L19.12|
;;;1223           *ptbl++ = 0;
00000c  2300              MOVS     r3,#0
00000e  f8013b01          STRB     r3,[r1],#1
000012  1c53              ADDS     r3,r2,#1              ;1222
000014  b2da              UXTB     r2,r3                 ;1222
                  |L19.22|
000016  2a04              CMP      r2,#4                 ;1222
000018  dbf8              BLT      |L19.12|
;;;1224       }
;;;1225   }
00001a  4770              BX       lr
;;;1226   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1240   
;;;1241   static  void  OS_InitEventList (void)
000000  b530              PUSH     {r4,r5,lr}
;;;1242   {
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  f44f71a0          MOV      r1,#0x140
000006  4810              LDR      r0,|L20.72|
000008  f7fffffe          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
00000c  4b0e              LDR      r3,|L20.72|
;;;1252       pevent2 = &OSEventTbl[1];
00000e  f1030520          ADD      r5,r3,#0x20
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
000012  2400              MOVS     r4,#0
000014  e00a              B        |L20.44|
                  |L20.22|
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000016  2000              MOVS     r0,#0
000018  7018              STRB     r0,[r3,#0]
;;;1255           pevent1->OSEventPtr     = pevent2;
00001a  605d              STR      r5,[r3,#4]
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
00001c  203f              MOVS     r0,#0x3f
00001e  73d8              STRB     r0,[r3,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
000020  2100              MOVS     r1,#0
000022  7419              STRB     r1,[r3,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
000024  3320              ADDS     r3,r3,#0x20
;;;1261           pevent2++;
000026  3520              ADDS     r5,r5,#0x20
000028  1c60              ADDS     r0,r4,#1              ;1253
00002a  b284              UXTH     r4,r0                 ;1253
                  |L20.44|
00002c  2c09              CMP      r4,#9                 ;1253
00002e  dbf2              BLT      |L20.22|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000030  2000              MOVS     r0,#0
000032  7018              STRB     r0,[r3,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
000034  6058              STR      r0,[r3,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
000036  203f              MOVS     r0,#0x3f
000038  73d8              STRB     r0,[r3,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
00003a  2100              MOVS     r1,#0
00003c  7419              STRB     r1,[r3,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
00003e  4802              LDR      r0,|L20.72|
000040  4902              LDR      r1,|L20.76|
000042  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
000044  bd30              POP      {r4,r5,pc}
;;;1281   /*$PAGE*/
                          ENDP

000046  0000              DCW      0x0000
                  |L20.72|
                          DCD      OSEventTbl
                  |L20.76|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;1294   
;;;1295   static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;1296   {
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
000002  490a              LDR      r1,|L21.44|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000006  490a              LDR      r1,|L21.48|
000008  7008              STRB     r0,[r1,#0]
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
00000a  490a              LDR      r1,|L21.52|
00000c  7008              STRB     r0,[r1,#0]
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
00000e  490a              LDR      r1,|L21.56|
000010  7008              STRB     r0,[r1,#0]
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
000012  490a              LDR      r1,|L21.60|
000014  7008              STRB     r0,[r1,#0]
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000016  490a              LDR      r1,|L21.64|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
00001a  490a              LDR      r1,|L21.68|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
00001e  490a              LDR      r1,|L21.72|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1313       OSIdleCtrMax  = 0L;
000022  490a              LDR      r1,|L21.76|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
000026  490a              LDR      r1,|L21.80|
000028  7008              STRB     r0,[r1,#0]
;;;1315   #endif
;;;1316   }
00002a  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  |L21.44|
                          DCD      OSTime
                  |L21.48|
                          DCD      OSIntNesting
                  |L21.52|
                          DCD      OSLockNesting
                  |L21.56|
                          DCD      OSTaskCtr
                  |L21.60|
                          DCD      OSRunning
                  |L21.64|
                          DCD      OSCtxSwCtr
                  |L21.68|
                          DCD      OSIdleCtr
                  |L21.72|
                          DCD      OSIdleCtrRun
                  |L21.76|
                          DCD      OSIdleCtrMax
                  |L21.80|
                          DCD      OSStatRdy

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;1330   
;;;1331   static  void  OS_InitRdyList (void)
000000  2200              MOVS     r2,#0
;;;1332   {
;;;1333       INT8U    i;
;;;1334   #if OS_LOWEST_PRIO <= 63
;;;1335       INT8U   *prdytbl;
;;;1336   #else
;;;1337       INT16U  *prdytbl;
;;;1338   #endif
;;;1339   
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000002  4b0b              LDR      r3,|L22.48|
000004  701a              STRB     r2,[r3,#0]
;;;1342       prdytbl       = &OSRdyTbl[0];
000006  490b              LDR      r1,|L22.52|
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
000008  2000              MOVS     r0,#0
00000a  e004              B        |L22.22|
                  |L22.12|
;;;1344           *prdytbl++ = 0;
00000c  2200              MOVS     r2,#0
00000e  f8012b01          STRB     r2,[r1],#1
000012  1c42              ADDS     r2,r0,#1              ;1343
000014  b2d0              UXTB     r0,r2                 ;1343
                  |L22.22|
000016  2804              CMP      r0,#4                 ;1343
000018  dbf8              BLT      |L22.12|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
00001a  2200              MOVS     r2,#0
00001c  4b06              LDR      r3,|L22.56|
00001e  701a              STRB     r2,[r3,#0]
;;;1348       OSPrioHighRdy = 0;
000020  4b06              LDR      r3,|L22.60|
000022  701a              STRB     r2,[r3,#0]
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
000024  4b06              LDR      r3,|L22.64|
000026  601a              STR      r2,[r3,#0]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
000028  4b06              LDR      r3,|L22.68|
00002a  601a              STR      r2,[r3,#0]  ; OSTCBCur
;;;1352   }
00002c  4770              BX       lr
;;;1353   
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      OSRdyGrp
                  |L22.52|
                          DCD      OSRdyTbl
                  |L22.56|
                          DCD      OSPrioCur
                  |L22.60|
                          DCD      OSPrioHighRdy
                  |L22.64|
                          DCD      OSTCBHighRdy
                  |L22.68|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1499   
;;;1500   static  void  OS_InitTCBList (void)
000000  b530              PUSH     {r4,r5,lr}
;;;1501   {
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f61fd          MOV      r1,#0x7e8
000006  4814              LDR      r0,|L23.88|
000008  f7fffffe          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  2180              MOVS     r1,#0x80
00000e  4813              LDR      r0,|L23.92|
000010  f7fffffe          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
000014  4b10              LDR      r3,|L23.88|
;;;1510       ptcb2 = &OSTCBTbl[1];
000016  f103055c          ADD      r5,r3,#0x5c
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
00001a  2400              MOVS     r4,#0
00001c  e00a              B        |L23.52|
                  |L23.30|
;;;1512           ptcb1->OSTCBNext = ptcb2;
00001e  615d              STR      r5,[r3,#0x14]
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000020  203f              MOVS     r0,#0x3f
000022  f883004c          STRB     r0,[r3,#0x4c]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000026  2100              MOVS     r1,#0
000028  204d              MOVS     r0,#0x4d
00002a  54c1              STRB     r1,[r0,r3]
;;;1516   #endif
;;;1517           ptcb1++;
00002c  335c              ADDS     r3,r3,#0x5c
;;;1518           ptcb2++;
00002e  355c              ADDS     r5,r5,#0x5c
000030  1c60              ADDS     r0,r4,#1              ;1511
000032  b2c4              UXTB     r4,r0                 ;1511
                  |L23.52|
000034  2c15              CMP      r4,#0x15              ;1511
000036  d3f2              BCC      |L23.30|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
000038  2000              MOVS     r0,#0
00003a  6158              STR      r0,[r3,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
00003c  203f              MOVS     r0,#0x3f
00003e  f883004c          STRB     r0,[r3,#0x4c]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000042  2100              MOVS     r1,#0
000044  204d              MOVS     r0,#0x4d
000046  54c1              STRB     r1,[r0,r3]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000048  2000              MOVS     r0,#0
00004a  4905              LDR      r1,|L23.96|
00004c  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
00004e  4802              LDR      r0,|L23.88|
000050  4904              LDR      r1,|L23.100|
000052  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1527   }
000054  bd30              POP      {r4,r5,pc}
;;;1528   /*$PAGE*/
                          ENDP

000056  0000              DCW      0x0000
                  |L23.88|
                          DCD      OSTCBTbl
                  |L23.92|
                          DCD      OSTCBPrioTbl
                  |L23.96|
                          DCD      OSTCBList
                  |L23.100|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;1367   
;;;1368   static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;1369   {
000002  b087              SUB      sp,sp,#0x1c
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L24.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  231f              MOVS     r3,#0x1f
00001a  4a07              LDR      r2,|L24.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L24.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L24.64|
000028  201f              MOVS     r0,#0x1f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1419   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      OSTaskIdleStk
                  |L24.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L24.60|
                          DCD      OS_TaskIdle
                  |L24.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1433   #if OS_TASK_STAT_EN > 0
;;;1434   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1435   {
000002  b087              SUB      sp,sp,#0x1c
;;;1436   #if OS_TASK_NAME_SIZE > 7
;;;1437       INT8U  err;
;;;1438   #endif
;;;1439   
;;;1440   
;;;1441   #if OS_TASK_CREATE_EXT_EN > 0
;;;1442       #if OS_STK_GROWTH == 1
;;;1443       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L25.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  231e              MOVS     r3,#0x1e
00001a  4a07              LDR      r2,|L25.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L25.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1444                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1445                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1446                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1447                             OS_TASK_STAT_ID,
;;;1448                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1449                             OS_TASK_STAT_STK_SIZE,
;;;1450                             (void *)0,                                   /* No TCB extension               */
;;;1451                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1452       #else
;;;1453       (void)OSTaskCreateExt(OS_TaskStat,
;;;1454                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1455                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1456                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1457                             OS_TASK_STAT_ID,
;;;1458                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1459                             OS_TASK_STAT_STK_SIZE,
;;;1460                             (void *)0,                                   /* No TCB extension               */
;;;1461                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1462       #endif
;;;1463   #else
;;;1464       #if OS_STK_GROWTH == 1
;;;1465       (void)OSTaskCreate(OS_TaskStat,
;;;1466                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1467                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1468                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1469       #else
;;;1470       (void)OSTaskCreate(OS_TaskStat,
;;;1471                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1472                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1473                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1474       #endif
;;;1475   #endif
;;;1476   
;;;1477   #if OS_TASK_NAME_SIZE > 14
;;;1478       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L25.64|
000028  201e              MOVS     r0,#0x1e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1479   #else
;;;1480   #if OS_TASK_NAME_SIZE > 7
;;;1481       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1482   #endif
;;;1483   #endif
;;;1484   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1485   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L25.52|
                          DCD      OSTaskStatStk
                  |L25.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L25.60|
                          DCD      OS_TaskStat
                  |L25.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1548   
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
000000  e004              B        |L26.12|
                  |L26.2|
;;;1550   {
;;;1551       while (size > 0) {
;;;1552           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1553           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L26.12|
00000c  2900              CMP      r1,#0                 ;1551
00000e  dcf8              BGT      |L26.2|
;;;1554       }
;;;1555   }
000010  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1580   
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
000000  e005              B        |L27.14|
                  |L27.2|
;;;1582   {
;;;1583       while (size > 0) {
;;;1584           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1585           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L27.14|
00000e  2a00              CMP      r2,#0                 ;1583
000010  dcf7              BGT      |L27.2|
;;;1586       }
;;;1587   }
000012  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1605   
;;;1606   void  OS_Sched (void)
000000  b510              PUSH     {r4,lr}
;;;1607   {
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
00000a  4813              LDR      r0,|L28.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f0              CBNZ     r0,|L28.78|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
000010  4812              LDR      r0,|L28.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9d8              CBNZ     r0,|L28.78|
;;;1617               OS_SchedNew();
000016  f7fffffe          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001a  4811              LDR      r0,|L28.96|
00001c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00001e  4911              LDR      r1,|L28.100|
000020  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000022  4288              CMP      r0,r1
000024  d013              BEQ      |L28.78|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000026  4810              LDR      r0,|L28.104|
000028  490d              LDR      r1,|L28.96|
00002a  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00002c  f8500021          LDR      r0,[r0,r1,LSL #2]
000030  490e              LDR      r1,|L28.108|
000032  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000034  4608              MOV      r0,r1
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6b80              LDR      r0,[r0,#0x38]
00003a  1c40              ADDS     r0,r0,#1
00003c  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
00003e  6388              STR      r0,[r1,#0x38]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000040  480b              LDR      r0,|L28.112|
000042  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000044  1c40              ADDS     r0,r0,#1
000046  490a              LDR      r1,|L28.112|
000048  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
00004a  f7fffffe          BL       OSCtxSw
                  |L28.78|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OS_CPU_SR_Restore
;;;1629   }
000054  bd10              POP      {r4,pc}
;;;1630   
                          ENDP

000056  0000              DCW      0x0000
                  |L28.88|
                          DCD      OSIntNesting
                  |L28.92|
                          DCD      OSLockNesting
                  |L28.96|
                          DCD      OSPrioHighRdy
                  |L28.100|
                          DCD      OSPrioCur
                  |L28.104|
                          DCD      OSTCBPrioTbl
                  |L28.108|
                          DCD      OSTCBHighRdy
                  |L28.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1647   
;;;1648   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L29.28|
;;;1649   {
;;;1650   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1651       INT8U   y;
;;;1652   
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L29.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L29.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L29.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L29.40|
000016  7011              STRB     r1,[r2,#0]
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
000018  4770              BX       lr
;;;1674   
                          ENDP

00001a  0000              DCW      0x0000
                  |L29.28|
                          DCD      OSUnMapTbl
                  |L29.32|
                          DCD      OSRdyGrp
                  |L29.36|
                          DCD      OSRdyTbl
                  |L29.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrCopy||, CODE, READONLY, ALIGN=1

                  OS_StrCopy PROC
;;;1695   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1696   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  4602              MOV      r2,r0
;;;1697   {
;;;1698       INT8U  len;
;;;1699   
;;;1700   
;;;1701       len = 0;
000002  2000              MOVS     r0,#0
;;;1702       while (*psrc != OS_ASCII_NUL) {
000004  e005              B        |L30.18|
                  |L30.6|
;;;1703           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8023b01          STRB     r3,[r2],#1
;;;1704           len++;
00000e  1c43              ADDS     r3,r0,#1
000010  b2d8              UXTB     r0,r3
                  |L30.18|
000012  780b              LDRB     r3,[r1,#0]            ;1702
000014  2b00              CMP      r3,#0                 ;1702
000016  d1f6              BNE      |L30.6|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
000018  7013              STRB     r3,[r2,#0]
;;;1707       return (len);
;;;1708   }
00001a  4770              BX       lr
;;;1709   #endif
                          ENDP


                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1727   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1728   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1729   {
;;;1730       INT8U  len;
;;;1731   
;;;1732   
;;;1733       len = 0;
000002  2000              MOVS     r0,#0
;;;1734       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L31.12|
                  |L31.6|
;;;1735           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1736           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L31.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1734
00000e  2a00              CMP      r2,#0                 ;1734
000010  d1f9              BNE      |L31.6|
;;;1737       }
;;;1738       return (len);
;;;1739   }
000012  4770              BX       lr
;;;1740   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1921   
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1923   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001e  483a              LDR      r0,|L32.264|
000020  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
000022  2c00              CMP      r4,#0
000024  d06b              BEQ      |L32.254|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000026  3418              ADDS     r4,r4,#0x18
000028  f8540c04          LDR      r0,[r4,#-4]
00002c  4936              LDR      r1,|L32.264|
00002e  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
000030  9800              LDR      r0,[sp,#0]
000032  f7fffffe          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000036  f8446c18          STR      r6,[r4,#-0x18]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00003a  76a5              STRB     r5,[r4,#0x1a]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00003c  2000              MOVS     r0,#0
00003e  7620              STRB     r0,[r4,#0x18]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000040  7660              STRB     r0,[r4,#0x19]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
000042  82e0              STRH     r0,[r4,#0x16]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000044  f844ac14          STR      r10,[r4,#-0x14]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000048  f8449c0c          STR      r9,[r4,#-0xc]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00004c  f8447c10          STR      r7,[r4,#-0x10]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000050  f824bc08          STRH     r11,[r4,#-8]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000054  f8248c06          STRH     r8,[r4,#-6]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000058  77e0              STRB     r0,[r4,#0x1f]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
00005a  10e8              ASRS     r0,r5,#3
00005c  7720              STRB     r0,[r4,#0x1c]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
00005e  f0050007          AND      r0,r5,#7
000062  76e0              STRB     r0,[r4,#0x1b]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
000064  7f21              LDRB     r1,[r4,#0x1c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  77a0              STRB     r0,[r4,#0x1e]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
00006c  7ee1              LDRB     r1,[r4,#0x1b]
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  7760              STRB     r0,[r4,#0x1d]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000074  2000              MOVS     r0,#0
000076  6060              STR      r0,[r4,#4]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000078  60a0              STR      r0,[r4,#8]
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
00007a  6120              STR      r0,[r4,#0x10]
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00007c  60e0              STR      r0,[r4,#0xc]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
00007e  6220              STR      r0,[r4,#0x20]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
000080  62a0              STR      r0,[r4,#0x28]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
000082  6260              STR      r0,[r4,#0x24]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
000084  62e0              STR      r0,[r4,#0x2c]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
000086  6320              STR      r0,[r4,#0x30]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
000088  203f              MOVS     r0,#0x3f
00008a  f8840034          STRB     r0,[r4,#0x34]
00008e  3c18              SUBS     r4,r4,#0x18
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
000090  2100              MOVS     r1,#0
000092  204d              MOVS     r0,#0x4d
000094  5501              STRB     r1,[r0,r4]
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
0000a2  f7fffffe          BL       OS_CPU_SR_Save
0000a6  9000              STR      r0,[sp,#0]
;;;2005           OSTCBPrioTbl[prio] = ptcb;
0000a8  4818              LDR      r0,|L32.268|
0000aa  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000ae  4818              LDR      r0,|L32.272|
0000b0  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000b2  6160              STR      r0,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000b4  2000              MOVS     r0,#0
0000b6  61a0              STR      r0,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
0000b8  4815              LDR      r0,|L32.272|
0000ba  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000bc  b110              CBZ      r0,|L32.196|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
0000be  4814              LDR      r0,|L32.272|
0000c0  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000c2  6184              STR      r4,[r0,#0x18]
                  |L32.196|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
0000c4  4812              LDR      r0,|L32.272|
0000c6  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000c8  3434              ADDS     r4,r4,#0x34
0000ca  78a0              LDRB     r0,[r4,#2]
0000cc  4911              LDR      r1,|L32.276|
0000ce  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000d0  4308              ORRS     r0,r0,r1
0000d2  4910              LDR      r1,|L32.276|
0000d4  7008              STRB     r0,[r1,#0]
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000d6  7820              LDRB     r0,[r4,#0]
0000d8  490f              LDR      r1,|L32.280|
0000da  5c08              LDRB     r0,[r1,r0]
0000dc  7861              LDRB     r1,[r4,#1]
0000de  4308              ORRS     r0,r0,r1
0000e0  f8141934          LDRB     r1,[r4],#-0x34
0000e4  4a0c              LDR      r2,|L32.280|
0000e6  5450              STRB     r0,[r2,r1]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000e8  480c              LDR      r0,|L32.284|
0000ea  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
0000ec  1c40              ADDS     r0,r0,#1
0000ee  490b              LDR      r1,|L32.284|
0000f0  7008              STRB     r0,[r1,#0]
;;;2015           OS_EXIT_CRITICAL();
0000f2  9800              LDR      r0,[sp,#0]
0000f4  f7fffffe          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
0000f8  2000              MOVS     r0,#0
                  |L32.250|
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
0000fa  e8bd8ff8          POP      {r3-r11,pc}
                  |L32.254|
0000fe  9800              LDR      r0,[sp,#0]            ;2018
000100  f7fffffe          BL       OS_CPU_SR_Restore
000104  2042              MOVS     r0,#0x42              ;2019
000106  e7f8              B        |L32.250|
                          ENDP

                  |L32.264|
                          DCD      OSTCBFreeList
                  |L32.268|
                          DCD      OSTCBPrioTbl
                  |L32.272|
                          DCD      OSTCBList
                  |L32.276|
                          DCD      OSRdyGrp
                  |L32.280|
                          DCD      OSRdyTbl
                  |L32.284|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1762   
;;;1763   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1764   {
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
000002  bf00              NOP      
                  |L33.4|
;;;1773           OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1774           OSIdleCtr++;
00000a  4805              LDR      r0,|L33.32|
00000c  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00000e  1c40              ADDS     r0,r0,#1
000010  4903              LDR      r1,|L33.32|
000012  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001a  f7fffffe          BL       OSTaskIdleHook
00001e  e7f1              B        |L33.4|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  |L33.32|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1804   #if OS_TASK_STAT_EN > 0
;;;1805   void  OS_TaskStat (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1806   {
;;;1807   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1808       OS_CPU_SR  cpu_sr = 0;
;;;1809   #endif
;;;1810   
;;;1811   
;;;1812   
;;;1813       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1814       while (OSStatRdy == OS_FALSE) {
000002  e002              B        |L34.10|
                  |L34.4|
;;;1815           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
000004  20c8              MOVS     r0,#0xc8
000006  f7fffffe          BL       OSTimeDly
                  |L34.10|
00000a  481a              LDR      r0,|L34.116|
00000c  7800              LDRB     r0,[r0,#0]            ;1814  ; OSStatRdy
00000e  2800              CMP      r0,#0                 ;1814
000010  d0f8              BEQ      |L34.4|
;;;1816       }
;;;1817       OSIdleCtrMax /= 100L;
000012  4819              LDR      r0,|L34.120|
000014  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000016  2164              MOVS     r1,#0x64
000018  fbb0f0f1          UDIV     r0,r0,r1
00001c  4916              LDR      r1,|L34.120|
00001e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1818       if (OSIdleCtrMax == 0L) {
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000024  b928              CBNZ     r0,|L34.50|
;;;1819           OSCPUUsage = 0;
000026  2000              MOVS     r0,#0
000028  4914              LDR      r1,|L34.124|
00002a  7008              STRB     r0,[r1,#0]
;;;1820           (void)OSTaskSuspend(OS_PRIO_SELF);
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       OSTaskSuspend
                  |L34.50|
;;;1821       }
;;;1822       for (;;) {
000032  bf00              NOP      
                  |L34.52|
;;;1823           OS_ENTER_CRITICAL();
000034  f7fffffe          BL       OS_CPU_SR_Save
000038  4604              MOV      r4,r0
;;;1824           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00003a  4811              LDR      r0,|L34.128|
00003c  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00003e  4911              LDR      r1,|L34.132|
000040  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1825           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
000042  2000              MOVS     r0,#0
000044  490e              LDR      r1,|L34.128|
000046  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1826           OS_EXIT_CRITICAL();
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       OS_CPU_SR_Restore
;;;1827           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
00004e  480d              LDR      r0,|L34.132|
000050  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
000052  4909              LDR      r1,|L34.120|
000054  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000056  fbb0f0f1          UDIV     r0,r0,r1
00005a  f1c00064          RSB      r0,r0,#0x64
00005e  4907              LDR      r1,|L34.124|
000060  7008              STRB     r0,[r1,#0]
;;;1828           OSTaskStatHook();                        /* Invoke user definable hook                         */
000062  f7fffffe          BL       OSTaskStatHook
;;;1829   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1830           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000066  f7fffffe          BL       OS_TaskStatStkChk
;;;1831   #endif
;;;1832           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
00006a  2064              MOVS     r0,#0x64
00006c  f7fffffe          BL       OSTimeDly
000070  e7e0              B        |L34.52|
;;;1833       }
;;;1834   }
;;;1835   #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L34.116|
                          DCD      OSStatRdy
                  |L34.120|
                          DCD      OSIdleCtrMax
                  |L34.124|
                          DCD      OSCPUUsage
                  |L34.128|
                          DCD      OSIdleCtr
                  |L34.132|
                          DCD      OSIdleCtrRun

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1849   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1850   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1851   {
;;;1852       OS_TCB      *ptcb;
;;;1853       OS_STK_DATA  stk_data;
;;;1854       INT8U        err;
;;;1855       INT8U        prio;
;;;1856   
;;;1857   
;;;1858       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L35.48|
                  |L35.6|
;;;1859           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1860           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L35.44|
;;;1861               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L35.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1862               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L35.44|
;;;1863                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L35.44|
;;;1864   #if OS_TASK_PROFILE_EN > 0
;;;1865                       #if OS_STK_GROWTH == 1
;;;1866                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  6460              STR      r0,[r4,#0x44]
;;;1867                       #else
;;;1868                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1869                       #endif
;;;1870                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000028  9801              LDR      r0,[sp,#4]
00002a  64a0              STR      r0,[r4,#0x48]
                  |L35.44|
00002c  1c68              ADDS     r0,r5,#1              ;1858
00002e  b2c5              UXTB     r5,r0                 ;1858
                  |L35.48|
000030  2d1f              CMP      r5,#0x1f              ;1858
000032  dde8              BLE      |L35.6|
;;;1871   #endif
;;;1872                   }
;;;1873               }
;;;1874           }
;;;1875       }
;;;1876   }
000034  bd7c              POP      {r2-r6,pc}
;;;1877   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L35.56|
                          DCD      OSTCBPrioTbl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        320
                  OSFlagTbl
                          %        140
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        2024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
000020  0000              DCB      0x00,0x00
                  OSRunning
000022  00                DCB      0x00
                  OSTaskCtr
000023  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  OSTime
                          DCD      0x00000000
