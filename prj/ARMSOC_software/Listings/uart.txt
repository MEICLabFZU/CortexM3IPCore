; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\include -I.\TTS -I.\OLED -I.\ucosii\config -I.\ucosii\port -I.\ucosii\source -I.\RTE\_Target_1 -ID:\Coding\MDKeil\ARM\PACK\ARM\CMSIS\5.4.0\Device\ARM\ARMCM3\Include -ID:\Coding\MDKeil\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DARMCM3 --omf_browse=.\objects\uart.crf src\UART.c]
                          THUMB

                          AREA ||i.Uart0GetLine||, CODE, READONLY, ALIGN=1

                  Uart0GetLine PROC
;;;291    
;;;292    unsigned int Uart0GetLine(char *s)
000000  b5f0              PUSH     {r4-r7,lr}
;;;293    {
000002  b089              SUB      sp,sp,#0x24
000004  4606              MOV      r6,r0
;;;294    	char ctemp, string[30]={0};
000006  2120              MOVS     r1,#0x20
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;295    	int cnt = 0, flag = 1;
00000e  2400              MOVS     r4,#0
000010  2701              MOVS     r7,#1
;;;296    	while(flag)
000012  e00e              B        |L1.50|
                  |L1.20|
;;;297    	{
;;;298    	ctemp = Uart0Getc();
000014  f7fffffe          BL       Uart0Getc
000018  4605              MOV      r5,r0
;;;299    	if (ctemp == '\n'){
00001a  2d0a              CMP      r5,#0xa
00001c  d105              BNE      |L1.42|
;;;300    		string[cnt] = '\0';
00001e  2000              MOVS     r0,#0
000020  a901              ADD      r1,sp,#4
000022  5508              STRB     r0,[r1,r4]
;;;301    		cnt++;
000024  1c64              ADDS     r4,r4,#1
;;;302    		flag = 0;
000026  2700              MOVS     r7,#0
;;;303    		continue;
000028  e003              B        |L1.50|
                  |L1.42|
;;;304    	}
;;;305    	else {
;;;306    		string[cnt] = ctemp;
00002a  a801              ADD      r0,sp,#4
00002c  5505              STRB     r5,[r0,r4]
;;;307    		cnt++;
00002e  1c64              ADDS     r4,r4,#1
000030  bf00              NOP                            ;303
                  |L1.50|
000032  2f00              CMP      r7,#0                 ;296
000034  d1ee              BNE      |L1.20|
;;;308    		}
;;;309    	}
;;;310    	strcpy(s,string);
000036  a901              ADD      r1,sp,#4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       strcpy
;;;311    	return cnt;
00003e  4620              MOV      r0,r4
;;;312    }
000040  b009              ADD      sp,sp,#0x24
000042  bdf0              POP      {r4-r7,pc}
;;;313    
                          ENDP


                          AREA ||i.Uart0Getc||, CODE, READONLY, ALIGN=1

                  Uart0Getc PROC
;;;246    // Get a character
;;;247    unsigned char Uart0Getc(void)
000000  bf00              NOP      
                  |L2.2|
;;;248    {
;;;249      unsigned char my_ch;
;;;250    
;;;251      while ((UART0->STATE & 2)!=2); // Wait if Receive Holding register is empty
000002  f04f2140          MOV      r1,#0x40004000
000006  6849              LDR      r1,[r1,#4]
000008  f0010102          AND      r1,r1,#2
00000c  2902              CMP      r1,#2
00000e  d1f8              BNE      |L2.2|
;;;252    
;;;253    
;;;254      my_ch = UART0->DATA;
000010  f04f2140          MOV      r1,#0x40004000
000014  6809              LDR      r1,[r1,#0]
000016  b2c8              UXTB     r0,r1
;;;255    
;;;256      //Convert CR to LF
;;;257      if(my_ch == '\r')
000018  280d              CMP      r0,#0xd
00001a  d100              BNE      |L2.30|
;;;258         my_ch = '\n';
00001c  200a              MOVS     r0,#0xa
                  |L2.30|
;;;259    	
;;;260      return (my_ch);
;;;261    }
00001e  4770              BX       lr
;;;262    
                          ENDP


                          AREA ||i.Uart0Getstr||, CODE, READONLY, ALIGN=1

                  Uart0Getstr PROC
;;;264    // Get a character
;;;265    char Uart0Getstr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267      unsigned char my_ch;
;;;268    	unsigned char cnt = 0;
000002  2000              MOVS     r0,#0
000004  4606              MOV      r6,r0
;;;269    	char *s;
;;;270    	while(my_ch != '\n')
000006  e017              B        |L3.56|
                  |L3.8|
;;;271    	{	
;;;272    		while ((UART0->STATE & 2)!=2); // Wait if Receive Holding register is empty
000008  bf00              NOP      
                  |L3.10|
00000a  f04f2040          MOV      r0,#0x40004000
00000e  6840              LDR      r0,[r0,#4]
000010  f0000002          AND      r0,r0,#2
000014  2802              CMP      r0,#2
000016  d1f8              BNE      |L3.10|
;;;273    
;;;274    		my_ch = UART0->DATA;
000018  f04f2040          MOV      r0,#0x40004000
00001c  6800              LDR      r0,[r0,#0]
00001e  b2c4              UXTB     r4,r0
;;;275    		
;;;276      //Convert CR to LF
;;;277    		if(my_ch == '\r')
000020  2c0d              CMP      r4,#0xd
000022  d103              BNE      |L3.44|
;;;278    		{
;;;279    			my_ch = '\n';
000024  240a              MOVS     r4,#0xa
;;;280    			cnt = 0;
000026  2600              MOVS     r6,#0
;;;281    			return (s);
000028  b2e8              UXTB     r0,r5
                  |L3.42|
;;;282    		}
;;;283    		else
;;;284    		{
;;;285    			cnt +=1;
;;;286    			strcat(s,my_ch);
;;;287    		}
;;;288    	}
;;;289      
;;;290    }
00002a  bd70              POP      {r4-r6,pc}
                  |L3.44|
00002c  1c70              ADDS     r0,r6,#1              ;285
00002e  b2c6              UXTB     r6,r0                 ;285
000030  4621              MOV      r1,r4                 ;286
000032  4628              MOV      r0,r5                 ;286
000034  f7fffffe          BL       strcat
                  |L3.56|
000038  2c0a              CMP      r4,#0xa               ;270
00003a  d1e5              BNE      |L3.8|
00003c  bf00              NOP      
00003e  e7f4              B        |L3.42|
;;;291    
                          ENDP


                          AREA ||i.Uart0Putc||, CODE, READONLY, ALIGN=1

                  Uart0Putc PROC
;;;228    
;;;229    	unsigned char Uart0Putc(unsigned char my_ch)
000000  bf00              NOP      
                  |L4.2|
;;;230    {
;;;231      while ((UART0->STATE & 1)); // Wait if Transmit Holding register is full
000002  f04f2140          MOV      r1,#0x40004000
000006  6849              LDR      r1,[r1,#4]
000008  f0010101          AND      r1,r1,#1
00000c  2900              CMP      r1,#0
00000e  d1f8              BNE      |L4.2|
;;;232      UART0->DATA = my_ch; // write to transmit holding register
000010  f04f2140          MOV      r1,#0x40004000
000014  6008              STR      r0,[r1,#0]
;;;233      return (my_ch);
;;;234    }
000016  4770              BX       lr
;;;235    
                          ENDP


                          AREA ||i.Uart1GetLine||, CODE, READONLY, ALIGN=1

                  Uart1GetLine PROC
;;;87     
;;;88     unsigned char* Uart1GetLine(char *s)
000000  b5f0              PUSH     {r4-r7,lr}
;;;89     {
000002  b089              SUB      sp,sp,#0x24
000004  4606              MOV      r6,r0
;;;90     	char ctemp, string[30] = {0};
000006  2120              MOVS     r1,#0x20
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;91     	int cnt = 0, flag = 1;
00000e  2500              MOVS     r5,#0
000010  2701              MOVS     r7,#1
;;;92     	while(flag)
000012  e00c              B        |L5.46|
                  |L5.20|
;;;93     	{
;;;94     	ctemp = Uart1Getc();
000014  f7fffffe          BL       Uart1Getc
000018  4604              MOV      r4,r0
;;;95     	if (ctemp == '\n'){
00001a  2c0a              CMP      r4,#0xa
00001c  d103              BNE      |L5.38|
;;;96     		string[cnt] = ctemp;
00001e  a801              ADD      r0,sp,#4
000020  5544              STRB     r4,[r0,r5]
;;;97     		flag = 0;
000022  2700              MOVS     r7,#0
;;;98     		continue;
000024  e003              B        |L5.46|
                  |L5.38|
;;;99     	}
;;;100    	else {
;;;101    		string[cnt] = ctemp;
000026  a801              ADD      r0,sp,#4
000028  5544              STRB     r4,[r0,r5]
;;;102    		cnt++;
00002a  1c6d              ADDS     r5,r5,#1
00002c  bf00              NOP                            ;98
                  |L5.46|
00002e  2f00              CMP      r7,#0                 ;92
000030  d1f0              BNE      |L5.20|
;;;103    		}
;;;104    	
;;;105    	}
;;;106    	
;;;107    	
;;;108    	
;;;109    //	char str[30];
;;;110    //	memcpy(str,string, 30);
;;;111    	strcpy(s,string);
000032  a901              ADD      r1,sp,#4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       strcpy
;;;112    	return cnt;
00003a  4628              MOV      r0,r5
;;;113    }
00003c  b009              ADD      sp,sp,#0x24
00003e  bdf0              POP      {r4-r7,pc}
;;;114    
                          ENDP


                          AREA ||i.Uart1Getc||, CODE, READONLY, ALIGN=2

                  Uart1Getc PROC
;;;70     // Get a character
;;;71     unsigned char Uart1Getc(void)
000000  bf00              NOP      
                  |L6.2|
;;;72     {
;;;73       unsigned char my_ch;
;;;74     
;;;75       while ((UART1->STATE & 2)!=2); // Wait if Receive Holding register is empty
000002  4906              LDR      r1,|L6.28|
000004  6849              LDR      r1,[r1,#4]
000006  f0010102          AND      r1,r1,#2
00000a  2902              CMP      r1,#2
00000c  d1f9              BNE      |L6.2|
;;;76     
;;;77     
;;;78       my_ch = UART1->DATA;
00000e  4903              LDR      r1,|L6.28|
000010  6809              LDR      r1,[r1,#0]
000012  b2c8              UXTB     r0,r1
;;;79     //	UART1->STATE & 0x8;
;;;80     
;;;81       //Convert CR to LF
;;;82       if(my_ch == '\r')
000014  280d              CMP      r0,#0xd
000016  d100              BNE      |L6.26|
;;;83          my_ch = '\n';
000018  200a              MOVS     r0,#0xa
                  |L6.26|
;;;84     
;;;85       return (my_ch);
;;;86     }
00001a  4770              BX       lr
;;;87     
                          ENDP

                  |L6.28|
                          DCD      0x40005000

                          AREA ||i.Uart1Putc||, CODE, READONLY, ALIGN=2

                  Uart1Putc PROC
;;;51     // Output a character
;;;52     	unsigned char Uart1Putc(unsigned char my_ch)
000000  bf00              NOP      
                  |L7.2|
;;;53     {
;;;54       while ((UART1->STATE & 1)); // Wait if Transmit Holding register is full
000002  4904              LDR      r1,|L7.20|
000004  6849              LDR      r1,[r1,#4]
000006  f0010101          AND      r1,r1,#1
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L7.2|
;;;55       UART1->DATA = my_ch;	// write to transmit holding register
00000e  4901              LDR      r1,|L7.20|
000010  6008              STR      r0,[r1,#0]
;;;56     
;;;57     	return (my_ch);
;;;58     }
000012  4770              BX       lr
;;;59     
                          ENDP

                  |L7.20|
                          DCD      0x40005000

                          AREA ||i.Uart2GetLine||, CODE, READONLY, ALIGN=1

                  Uart2GetLine PROC
;;;197    
;;;198    unsigned char * Uart2GetLine(char *s)
000000  b5f0              PUSH     {r4-r7,lr}
;;;199    {
000002  b089              SUB      sp,sp,#0x24
000004  4606              MOV      r6,r0
;;;200    	char ctemp, string[30]={0};
000006  2120              MOVS     r1,#0x20
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;201    	int cnt = 0, flag = 1;
00000e  2500              MOVS     r5,#0
000010  2701              MOVS     r7,#1
;;;202    	while(flag)
000012  e00c              B        |L8.46|
                  |L8.20|
;;;203    	{
;;;204    	ctemp = Uart2Getc();
000014  f7fffffe          BL       Uart2Getc
000018  4604              MOV      r4,r0
;;;205    	if (ctemp == '\n'){
00001a  2c0a              CMP      r4,#0xa
00001c  d103              BNE      |L8.38|
;;;206    		string[cnt] = ctemp;
00001e  a801              ADD      r0,sp,#4
000020  5544              STRB     r4,[r0,r5]
;;;207    		flag = 0;
000022  2700              MOVS     r7,#0
;;;208    		continue;
000024  e003              B        |L8.46|
                  |L8.38|
;;;209    	}
;;;210    	else {
;;;211    		string[cnt] = ctemp;
000026  a801              ADD      r0,sp,#4
000028  5544              STRB     r4,[r0,r5]
;;;212    		cnt++;
00002a  1c6d              ADDS     r5,r5,#1
00002c  bf00              NOP                            ;208
                  |L8.46|
00002e  2f00              CMP      r7,#0                 ;202
000030  d1f0              BNE      |L8.20|
;;;213    		}
;;;214    	}
;;;215    	strcpy(s,string);
000032  a901              ADD      r1,sp,#4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       strcpy
;;;216    	return cnt;
00003a  4628              MOV      r0,r5
;;;217    }
00003c  b009              ADD      sp,sp,#0x24
00003e  bdf0              POP      {r4-r7,pc}
;;;218    
                          ENDP


                          AREA ||i.Uart2Getc||, CODE, READONLY, ALIGN=2

                  Uart2Getc PROC
;;;180    // Get a character
;;;181    unsigned char Uart2Getc(void)
000000  bf00              NOP      
                  |L9.2|
;;;182    {
;;;183      unsigned char my_ch;
;;;184    
;;;185      while ((UART2->STATE & 2)!=2); // Wait if Receive Holding register is empty
000002  4906              LDR      r1,|L9.28|
000004  6849              LDR      r1,[r1,#4]
000006  f0010102          AND      r1,r1,#2
00000a  2902              CMP      r1,#2
00000c  d1f9              BNE      |L9.2|
;;;186    
;;;187    
;;;188      my_ch = UART2->DATA;
00000e  4903              LDR      r1,|L9.28|
000010  6809              LDR      r1,[r1,#0]
000012  b2c8              UXTB     r0,r1
;;;189    
;;;190      //Convert CR to LF
;;;191      if(my_ch == '\r')
000014  280d              CMP      r0,#0xd
000016  d100              BNE      |L9.26|
;;;192         my_ch = '\n';
000018  200a              MOVS     r0,#0xa
                  |L9.26|
;;;193    
;;;194      return (my_ch);
;;;195    }
00001a  4770              BX       lr
;;;196    
                          ENDP

                  |L9.28|
                          DCD      0x40006000

                          AREA ||i.Uart2Putc||, CODE, READONLY, ALIGN=2

                  Uart2Putc PROC
;;;162    
;;;163    	unsigned char Uart2Putc(unsigned char my_ch)
000000  bf00              NOP      
                  |L10.2|
;;;164    {
;;;165      while ((UART2->STATE & 1)); // Wait if Transmit Holding register is full
000002  4904              LDR      r1,|L10.20|
000004  6849              LDR      r1,[r1,#4]
000006  f0010101          AND      r1,r1,#1
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L10.2|
;;;166      UART2->DATA = my_ch; // write to transmit holding register
00000e  4901              LDR      r1,|L10.20|
000010  6008              STR      r0,[r1,#0]
;;;167      return my_ch;
;;;168    }
000012  4770              BX       lr
;;;169    
                          ENDP

                  |L10.20|
                          DCD      0x40006000

                          AREA ||i.mstrtof||, CODE, READONLY, ALIGN=2

                  mstrtof PROC
;;;336    */
;;;337    float mstrtof(char *num){  
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b08b              SUB      sp,sp,#0x2c
000006  4682              MOV      r10,r0
;;;338              
;;;339        double n = 0, sign = 1, scale = 0;  
000008  2100              MOVS     r1,#0
00000a  460c              MOV      r4,r1
00000c  460d              MOV      r5,r1
00000e  2600              MOVS     r6,#0
000010  4f63              LDR      r7,|L11.416|
000012  4688              MOV      r8,r1
000014  4689              MOV      r9,r1
;;;340        int subscale = 0, signsubscale = 1;  
000016  468b              MOV      r11,r1
000018  2001              MOVS     r0,#1
00001a  900a              STR      r0,[sp,#0x28]
;;;341      
;;;342        if (*num == '-') {  
00001c  f89a0000          LDRB     r0,[r10,#0]
000020  282d              CMP      r0,#0x2d
000022  d102              BNE      |L11.42|
;;;343            sign = -1, num++;   /* Has sign? */  
000024  4f5f              LDR      r7,|L11.420|
000026  f10a0a01          ADD      r10,r10,#1
                  |L11.42|
;;;344        }  
;;;345      
;;;346        while (*num == '0') {  
00002a  e001              B        |L11.48|
                  |L11.44|
;;;347            num++;  
00002c  f10a0a01          ADD      r10,r10,#1
                  |L11.48|
000030  f89a0000          LDRB     r0,[r10,#0]           ;346
000034  2830              CMP      r0,#0x30              ;346
000036  d0f9              BEQ      |L11.44|
;;;348        }  
;;;349      
;;;350        if (*num >= '1' && *num <= '9')   {  
000038  f89a0000          LDRB     r0,[r10,#0]
00003c  2831              CMP      r0,#0x31
00003e  db22              BLT      |L11.134|
000040  f89a0000          LDRB     r0,[r10,#0]
000044  2839              CMP      r0,#0x39
000046  dc1e              BGT      |L11.134|
;;;351            do {  
000048  bf00              NOP      
                  |L11.74|
;;;352                n = (n * 10.0) + (*num++ - '0');      
00004a  f81a1b01          LDRB     r1,[r10],#1
00004e  f1a10030          SUB      r0,r1,#0x30
000052  f7fffffe          BL       __aeabi_i2d
000056  2200              MOVS     r2,#0
000058  4b53              LDR      r3,|L11.424|
00005a  e9cd0108          STRD     r0,r1,[sp,#0x20]
00005e  4620              MOV      r0,r4
000060  4629              MOV      r1,r5
000062  f7fffffe          BL       __aeabi_dmul
000066  e9cd0106          STRD     r0,r1,[sp,#0x18]
00006a  e9dd2308          LDRD     r2,r3,[sp,#0x20]
00006e  f7fffffe          BL       __aeabi_dadd
000072  4604              MOV      r4,r0
000074  460d              MOV      r5,r1
;;;353            } while (*num >= '0' && *num <= '9'); /* Number? */  
000076  f89a0000          LDRB     r0,[r10,#0]
00007a  2830              CMP      r0,#0x30
00007c  db03              BLT      |L11.134|
00007e  f89a0000          LDRB     r0,[r10,#0]
000082  2839              CMP      r0,#0x39
000084  dde1              BLE      |L11.74|
                  |L11.134|
;;;354        }  
;;;355      
;;;356        if (*num == '.' && num[1] >= '0' && num[1] <= '9') {  
000086  f89a0000          LDRB     r0,[r10,#0]
00008a  282e              CMP      r0,#0x2e
00008c  d130              BNE      |L11.240|
00008e  f89a0001          LDRB     r0,[r10,#1]
000092  2830              CMP      r0,#0x30
000094  db2c              BLT      |L11.240|
000096  f89a0001          LDRB     r0,[r10,#1]
00009a  2839              CMP      r0,#0x39
00009c  dc28              BGT      |L11.240|
;;;357            num++;        
00009e  f10a0a01          ADD      r10,r10,#1
;;;358            do {      
0000a2  bf00              NOP      
                  |L11.164|
;;;359                n = (n * 10.0) + (*num++ -'0'), scale--;   
0000a4  f81a1b01          LDRB     r1,[r10],#1
0000a8  f1a10030          SUB      r0,r1,#0x30
0000ac  f7fffffe          BL       __aeabi_i2d
0000b0  2200              MOVS     r2,#0
0000b2  4b3d              LDR      r3,|L11.424|
0000b4  e9cd0108          STRD     r0,r1,[sp,#0x20]
0000b8  4620              MOV      r0,r4
0000ba  4629              MOV      r1,r5
0000bc  f7fffffe          BL       __aeabi_dmul
0000c0  e9cd0106          STRD     r0,r1,[sp,#0x18]
0000c4  e9dd2308          LDRD     r2,r3,[sp,#0x20]
0000c8  f7fffffe          BL       __aeabi_dadd
0000cc  4604              MOV      r4,r0
0000ce  460d              MOV      r5,r1
0000d0  2200              MOVS     r2,#0
0000d2  4b33              LDR      r3,|L11.416|
0000d4  4640              MOV      r0,r8
0000d6  4649              MOV      r1,r9
0000d8  f7fffffe          BL       __aeabi_dsub
0000dc  4680              MOV      r8,r0
0000de  4689              MOV      r9,r1
;;;360            } while (*num >= '0' && *num <= '9');  
0000e0  f89a0000          LDRB     r0,[r10,#0]
0000e4  2830              CMP      r0,#0x30
0000e6  db03              BLT      |L11.240|
0000e8  f89a0000          LDRB     r0,[r10,#0]
0000ec  2839              CMP      r0,#0x39
0000ee  ddd9              BLE      |L11.164|
                  |L11.240|
;;;361        }   /* Fractional part? */  
;;;362      
;;;363        if (*num == 'e' || *num == 'E') {   /* Exponent? */  
0000f0  f89a0000          LDRB     r0,[r10,#0]
0000f4  2865              CMP      r0,#0x65
0000f6  d003              BEQ      |L11.256|
0000f8  f89a0000          LDRB     r0,[r10,#0]
0000fc  2845              CMP      r0,#0x45
0000fe  d121              BNE      |L11.324|
                  |L11.256|
;;;364            num++;  
000100  f10a0a01          ADD      r10,r10,#1
;;;365            if (*num == '+') {  
000104  f89a0000          LDRB     r0,[r10,#0]
000108  282b              CMP      r0,#0x2b
00010a  d102              BNE      |L11.274|
;;;366                num++;    
00010c  f10a0a01          ADD      r10,r10,#1
000110  e008              B        |L11.292|
                  |L11.274|
;;;367            } else if (*num == '-') {   
000112  f89a0000          LDRB     r0,[r10,#0]
000116  282d              CMP      r0,#0x2d
000118  d104              BNE      |L11.292|
;;;368                signsubscale = -1, num++;       /* With sign? */  
00011a  f04f30ff          MOV      r0,#0xffffffff
00011e  900a              STR      r0,[sp,#0x28]
000120  f10a0a01          ADD      r10,r10,#1
                  |L11.292|
;;;369            }  
;;;370      
;;;371            while (*num >= '0' && *num <= '9' ) {   
000124  e006              B        |L11.308|
                  |L11.294|
;;;372                subscale = (subscale * 10) + (*num++ - '0');    /* Number? */  
000126  f81a0b01          LDRB     r0,[r10],#1
00012a  3830              SUBS     r0,r0,#0x30
00012c  eb0b018b          ADD      r1,r11,r11,LSL #2
000130  eb000b41          ADD      r11,r0,r1,LSL #1
                  |L11.308|
000134  f89a0000          LDRB     r0,[r10,#0]           ;371
000138  2830              CMP      r0,#0x30              ;371
00013a  db03              BLT      |L11.324|
00013c  f89a0000          LDRB     r0,[r10,#0]           ;371
000140  2839              CMP      r0,#0x39              ;371
000142  ddf0              BLE      |L11.294|
                  |L11.324|
;;;373            }  
;;;374        }  
;;;375      
;;;376        n = sign * n * pow(10.0, (scale + subscale * signsubscale));    /* number = +/- number.fraction * 10^ +/- exponent */  
000144  990a              LDR      r1,[sp,#0x28]
000146  fb0bf001          MUL      r0,r11,r1
00014a  f7fffffe          BL       __aeabi_i2d
00014e  4642              MOV      r2,r8
000150  464b              MOV      r3,r9
000152  e9cd0100          STRD     r0,r1,[sp,#0]
000156  f7fffffe          BL       __aeabi_dadd
00015a  4602              MOV      r2,r0
00015c  460b              MOV      r3,r1
00015e  e9cd0102          STRD     r0,r1,[sp,#8]
000162  2000              MOVS     r0,#0
000164  4910              LDR      r1,|L11.424|
000166  f7fffffe          BL       pow
00016a  9005              STR      r0,[sp,#0x14]
00016c  f7fffffe          BL       __aeabi_i2d
000170  4622              MOV      r2,r4
000172  462b              MOV      r3,r5
000174  e9cd0108          STRD     r0,r1,[sp,#0x20]
000178  4630              MOV      r0,r6
00017a  4639              MOV      r1,r7
00017c  f7fffffe          BL       __aeabi_dmul
000180  e9cd0106          STRD     r0,r1,[sp,#0x18]
000184  e9dd2308          LDRD     r2,r3,[sp,#0x20]
000188  f7fffffe          BL       __aeabi_dmul
00018c  4604              MOV      r4,r0
00018e  460d              MOV      r5,r1
;;;377          
;;;378        return n;  
000190  4620              MOV      r0,r4
000192  4629              MOV      r1,r5
000194  f7fffffe          BL       __aeabi_d2f
;;;379    } 
000198  b00b              ADD      sp,sp,#0x2c
00019a  e8bd8ff0          POP      {r4-r11,pc}
;;;380    
                          ENDP

00019e  0000              DCW      0x0000
                  |L11.416|
                          DCD      0x3ff00000
                  |L11.420|
                          DCD      0xbff00000
                  |L11.424|
                          DCD      0x40240000

                          AREA ||i.toDouble||, CODE, READONLY, ALIGN=2

                  toDouble PROC
;;;381    
;;;382    double toDouble(char num[]) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4605              MOV      r5,r0
;;;383        int i = 0,base;
000008  2400              MOVS     r4,#0
;;;384        double dnum1 = 0,dnum2 = 0;
00000a  2100              MOVS     r1,#0
00000c  4689              MOV      r9,r1
00000e  468a              MOV      r10,r1
000010  460f              MOV      r7,r1
000012  4688              MOV      r8,r1
;;;385        while(num[i] && num[i] != '.') {
000014  e019              B        |L12.74|
                  |L12.22|
;;;386            dnum1 = 10 * dnum1 + num[i] - '0';
000016  5d28              LDRB     r0,[r5,r4]
000018  f7fffffe          BL       __aeabi_ui2d
00001c  464a              MOV      r2,r9
00001e  4653              MOV      r3,r10
000020  e9cd0102          STRD     r0,r1,[sp,#8]
000024  2000              MOVS     r0,#0
000026  4929              LDR      r1,|L12.204|
000028  f7fffffe          BL       __aeabi_dmul
00002c  e9cd0100          STRD     r0,r1,[sp,#0]
000030  e9dd2302          LDRD     r2,r3,[sp,#8]
000034  f7fffffe          BL       __aeabi_dadd
000038  2200              MOVS     r2,#0
00003a  4b25              LDR      r3,|L12.208|
00003c  e9cd0104          STRD     r0,r1,[sp,#0x10]
000040  f7fffffe          BL       __aeabi_dsub
000044  4681              MOV      r9,r0
000046  468a              MOV      r10,r1
;;;387            ++i;
000048  1c64              ADDS     r4,r4,#1
                  |L12.74|
00004a  5d28              LDRB     r0,[r5,r4]            ;385
00004c  b110              CBZ      r0,|L12.84|
00004e  5d28              LDRB     r0,[r5,r4]            ;385
000050  282e              CMP      r0,#0x2e              ;385
000052  d1e0              BNE      |L12.22|
                  |L12.84|
;;;388        }
;;;389        if(num[i] == '.') {
000054  5d28              LDRB     r0,[r5,r4]
000056  282e              CMP      r0,#0x2e
000058  d12f              BNE      |L12.186|
;;;390            ++i; // ??'.'
00005a  1c64              ADDS     r4,r4,#1
;;;391            base = 1;
00005c  2601              MOVS     r6,#1
;;;392            while(num[i] != '\0') {
00005e  e01c              B        |L12.154|
                  |L12.96|
;;;393                dnum2 = 10 * dnum2 + num[i] - '0';
000060  5d28              LDRB     r0,[r5,r4]
000062  f7fffffe          BL       __aeabi_ui2d
000066  463a              MOV      r2,r7
000068  4643              MOV      r3,r8
00006a  e9cd0102          STRD     r0,r1,[sp,#8]
00006e  2000              MOVS     r0,#0
000070  4916              LDR      r1,|L12.204|
000072  f7fffffe          BL       __aeabi_dmul
000076  e9cd0100          STRD     r0,r1,[sp,#0]
00007a  e9dd2302          LDRD     r2,r3,[sp,#8]
00007e  f7fffffe          BL       __aeabi_dadd
000082  2200              MOVS     r2,#0
000084  4b12              LDR      r3,|L12.208|
000086  e9cd0104          STRD     r0,r1,[sp,#0x10]
00008a  f7fffffe          BL       __aeabi_dsub
00008e  4607              MOV      r7,r0
000090  4688              MOV      r8,r1
;;;394                base *= 10;
000092  eb060086          ADD      r0,r6,r6,LSL #2
000096  0046              LSLS     r6,r0,#1
;;;395                ++i;
000098  1c64              ADDS     r4,r4,#1
                  |L12.154|
00009a  5d28              LDRB     r0,[r5,r4]            ;392
00009c  2800              CMP      r0,#0                 ;392
00009e  d1df              BNE      |L12.96|
;;;396            }
;;;397            dnum2 /= base;
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       __aeabi_i2d
0000a6  4602              MOV      r2,r0
0000a8  460b              MOV      r3,r1
0000aa  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000ae  4638              MOV      r0,r7
0000b0  4641              MOV      r1,r8
0000b2  f7fffffe          BL       __aeabi_ddiv
0000b6  4607              MOV      r7,r0
0000b8  4688              MOV      r8,r1
                  |L12.186|
;;;398        }
;;;399        return dnum1 + dnum2;
0000ba  463a              MOV      r2,r7
0000bc  4643              MOV      r3,r8
0000be  4648              MOV      r0,r9
0000c0  4651              MOV      r1,r10
0000c2  f7fffffe          BL       __aeabi_dadd
;;;400    }
0000c6  b006              ADD      sp,sp,#0x18
0000c8  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  |L12.204|
                          DCD      0x40240000
                  |L12.208|
                          DCD      0x40480000

                          AREA ||i.uart0init||, CODE, READONLY, ALIGN=1

                  uart0init PROC
;;;236    //uart1 init
;;;237    void uart0init(void)
000000  f640202c          MOV      r0,#0xa2c
;;;238    {
;;;239    //	UART2->BAUDDIV = 0x16;	//only for test
;;;240    	UART0->BAUDDIV = 0x0a2c;
000004  f04f2140          MOV      r1,#0x40004000
000008  6108              STR      r0,[r1,#0x10]
;;;241    	UART0->CTRL = 0x03;	//r&x
00000a  2003              MOVS     r0,#3
00000c  6088              STR      r0,[r1,#8]
;;;242    }
00000e  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.uart1init||, CODE, READONLY, ALIGN=2

                  uart1init PROC
;;;60     //uart1 init
;;;61     void uart1init(void)
000000  f640202c          MOV      r0,#0xa2c
;;;62     {
;;;63     //	UART1->BAUDDIV = 0x16;	//only for test
;;;64     	UART1->BAUDDIV = 0x0a2c;
000004  4902              LDR      r1,|L14.16|
000006  6108              STR      r0,[r1,#0x10]
;;;65     	UART1->CTRL = 0x03;	//r&x
000008  2003              MOVS     r0,#3
00000a  6088              STR      r0,[r1,#8]
;;;66     }
00000c  4770              BX       lr
;;;67     
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40005000

                          AREA ||i.uart2init||, CODE, READONLY, ALIGN=2

                  uart2init PROC
;;;170    //uart1 init
;;;171    void uart2init(void)
000000  f640202c          MOV      r0,#0xa2c
;;;172    {
;;;173    //	UART2->BAUDDIV = 0x16;	//only for test
;;;174    	UART2->BAUDDIV = 0x0a2c;
000004  4902              LDR      r1,|L15.16|
000006  6108              STR      r0,[r1,#0x10]
;;;175    	UART2->CTRL = 0x03;	//r&x
000008  2003              MOVS     r0,#3
00000a  6088              STR      r0,[r1,#8]
;;;176    }
00000c  4770              BX       lr
;;;177    
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      0x40006000

;*** Start embedded assembler ***

#line 1 "src\\UART.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_b3578658____REV16|
#line 129 ".\\include\\core_cmInstr.h"
|__asm___6_UART_c_b3578658____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_UART_c_b3578658____REVSH|
#line 144
|__asm___6_UART_c_b3578658____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
