; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\os_sem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\include -I.\TTS -I.\OLED -I.\ucosii\config -I.\ucosii\port -I.\ucosii\source -I.\RTE\_Target_1 -ID:\Coding\MDKeil\ARM\PACK\ARM\CMSIS\5.4.0\Device\ARM\ARMCM3\Include -ID:\Coding\MDKeil\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DARMCM3 --omf_browse=.\objects\os_sem.crf ucosii\source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemAccept||, CODE, READONLY, ALIGN=1

                  OSSemAccept PROC
;;;48     #if OS_SEM_ACCEPT_EN > 0
;;;49     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         INT16U     cnt;
;;;52     #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;53         OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0
;;;59         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;60             return (0);
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L1.16|
;;;64             return (0);
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         cnt = pevent->OSEventCnt;
;;;68         if (cnt > 0) {                                    /* See if resource is available                  */
;;;69             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;70         }
;;;71         OS_EXIT_CRITICAL();
;;;72         return (cnt);                                     /* Return semaphore count                        */
;;;73     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4606              MOV      r6,r0                 ;66
000016  8925              LDRH     r5,[r4,#8]            ;67
000018  2d00              CMP      r5,#0                 ;68
00001a  dd02              BLE      |L1.34|
00001c  8920              LDRH     r0,[r4,#8]            ;69
00001e  1e40              SUBS     r0,r0,#1              ;69
000020  8120              STRH     r0,[r4,#8]            ;69
                  |L1.34|
000022  4630              MOV      r0,r6                 ;71
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  4628              MOV      r0,r5                 ;72
00002a  e7f0              B        |L1.14|
;;;74     #endif
                          ENDP


                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;93     
;;;94     OS_EVENT  *OSSemCreate (INT16U cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4605              MOV      r5,r0
;;;96         OS_EVENT  *pevent;
;;;97     #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
000006  4812              LDR      r0,|L2.80|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  2800              CMP      r0,#0
00000c  dd01              BLE      |L2.18|
;;;104            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;105        }
;;;106        OS_ENTER_CRITICAL();
;;;107        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;108        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;109            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;110        }
;;;111        OS_EXIT_CRITICAL();
;;;112        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;113            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;114            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;115            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;116    #if OS_EVENT_NAME_SIZE > 1
;;;117            pevent->OSEventName[0] = '?';                      /* Unknown name                             */
;;;118            pevent->OSEventName[1] = OS_ASCII_NUL;
;;;119    #endif
;;;120            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;121        }
;;;122        return (pevent);
;;;123    }
000010  bd70              POP      {r4-r6,pc}
                  |L2.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;106
000018  480e              LDR      r0,|L2.84|
00001a  6804              LDR      r4,[r0,#0]            ;107  ; OSEventFreeList
00001c  6800              LDR      r0,[r0,#0]            ;108  ; OSEventFreeList
00001e  b120              CBZ      r0,|L2.42|
000020  480c              LDR      r0,|L2.84|
000022  6800              LDR      r0,[r0,#0]            ;109  ; OSEventFreeList
000024  6840              LDR      r0,[r0,#4]            ;109
000026  490b              LDR      r1,|L2.84|
000028  6008              STR      r0,[r1,#0]            ;109  ; OSEventFreeList
                  |L2.42|
00002a  4630              MOV      r0,r6                 ;111
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  b15c              CBZ      r4,|L2.74|
000032  2003              MOVS     r0,#3                 ;113
000034  7020              STRB     r0,[r4,#0]            ;113
000036  8125              STRH     r5,[r4,#8]            ;114
000038  2000              MOVS     r0,#0                 ;115
00003a  6060              STR      r0,[r4,#4]            ;115
00003c  203f              MOVS     r0,#0x3f              ;117
00003e  73e0              STRB     r0,[r4,#0xf]          ;117
000040  2100              MOVS     r1,#0                 ;118
000042  7421              STRB     r1,[r4,#0x10]         ;118
000044  4620              MOV      r0,r4                 ;120
000046  f7fffffe          BL       OS_EventWaitListInit
                  |L2.74|
00004a  4620              MOV      r0,r4                 ;122
00004c  e7e0              B        |L2.16|
;;;124    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      OSIntNesting
                  |L2.84|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;163    #if OS_SEM_DEL_EN > 0
;;;164    OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;165    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;166        BOOLEAN    tasks_waiting;
;;;167        OS_EVENT  *pevent_return;
;;;168    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;169        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0900          MOV      r9,#0
;;;170    #endif
;;;171    
;;;172    
;;;173    
;;;174    #if OS_ARG_CHK_EN > 0
;;;175        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;176            return (pevent);
;;;177        }
;;;178        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;179            *perr = OS_ERR_PEVENT_NULL;
;;;180            return (pevent);
;;;181        }
;;;182    #endif
;;;183        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L3.30|
;;;184            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;185            return (pevent);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;186        }
;;;187        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
;;;188            *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
;;;189            return (pevent);
;;;190        }
;;;191        OS_ENTER_CRITICAL();
;;;192        if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
;;;193            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;194        } else {
;;;195            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;196        }
;;;197        switch (opt) {
;;;198            case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
;;;199                 if (tasks_waiting == OS_FALSE) {
;;;200    #if OS_EVENT_NAME_SIZE > 1
;;;201                     pevent->OSEventName[0] = '?';             /* Unknown name                             */
;;;202                     pevent->OSEventName[1] = OS_ASCII_NUL;
;;;203    #endif
;;;204                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;205                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;206                     pevent->OSEventCnt     = 0;
;;;207                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;208                     OS_EXIT_CRITICAL();
;;;209                     *perr                  = OS_ERR_NONE;
;;;210                     pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
;;;211                 } else {
;;;212                     OS_EXIT_CRITICAL();
;;;213                     *perr                  = OS_ERR_TASK_WAITING;
;;;214                     pevent_return          = pevent;
;;;215                 }
;;;216                 break;
;;;217    
;;;218            case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
;;;219                 while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
;;;220                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;221                 }
;;;222    #if OS_EVENT_NAME_SIZE > 1
;;;223                 pevent->OSEventName[0] = '?';                 /* Unknown name                             */
;;;224                 pevent->OSEventName[1] = OS_ASCII_NUL;
;;;225    #endif
;;;226                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;227                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;228                 pevent->OSEventCnt     = 0;
;;;229                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;230                 OS_EXIT_CRITICAL();
;;;231                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;232                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;233                 }
;;;234                 *perr                  = OS_ERR_NONE;
;;;235                 pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
;;;236                 break;
;;;237    
;;;238            default:
;;;239                 OS_EXIT_CRITICAL();
;;;240                 *perr                  = OS_ERR_INVALID_OPT;
;;;241                 pevent_return          = pevent;
;;;242                 break;
;;;243        }
;;;244        return (pevent_return);
;;;245    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  482f              LDR      r0,|L3.220|
000020  7800              LDRB     r0,[r0,#0]            ;187  ; OSIntNesting
000022  2800              CMP      r0,#0                 ;187
000024  dd03              BLE      |L3.46|
000026  200f              MOVS     r0,#0xf               ;188
000028  7028              STRB     r0,[r5,#0]            ;188
00002a  4620              MOV      r0,r4                 ;189
00002c  e7f5              B        |L3.26|
                  |L3.46|
00002e  f7fffffe          BL       OS_CPU_SR_Save
000032  4681              MOV      r9,r0                 ;191
000034  7aa0              LDRB     r0,[r4,#0xa]          ;192
000036  b108              CBZ      r0,|L3.60|
000038  2701              MOVS     r7,#1                 ;193
00003a  e000              B        |L3.62|
                  |L3.60|
00003c  2700              MOVS     r7,#0                 ;195
                  |L3.62|
00003e  f1b80f00          CMP      r8,#0                 ;197
000042  d003              BEQ      |L3.76|
000044  f1b80f01          CMP      r8,#1                 ;197
000048  d13e              BNE      |L3.200|
00004a  e01b              B        |L3.132|
                  |L3.76|
00004c  b99f              CBNZ     r7,|L3.118|
00004e  203f              MOVS     r0,#0x3f              ;201
000050  73e0              STRB     r0,[r4,#0xf]          ;201
000052  2100              MOVS     r1,#0                 ;202
000054  7421              STRB     r1,[r4,#0x10]         ;202
000056  2000              MOVS     r0,#0                 ;204
000058  7020              STRB     r0,[r4,#0]            ;204
00005a  4821              LDR      r0,|L3.224|
00005c  6800              LDR      r0,[r0,#0]            ;205  ; OSEventFreeList
00005e  6060              STR      r0,[r4,#4]            ;205
000060  2000              MOVS     r0,#0                 ;206
000062  8120              STRH     r0,[r4,#8]            ;206
000064  481e              LDR      r0,|L3.224|
000066  6004              STR      r4,[r0,#0]            ;207  ; OSEventFreeList
000068  4648              MOV      r0,r9                 ;208
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  2000              MOVS     r0,#0                 ;209
000070  7028              STRB     r0,[r5,#0]            ;209
000072  2600              MOVS     r6,#0                 ;210
000074  e005              B        |L3.130|
                  |L3.118|
000076  4648              MOV      r0,r9                 ;212
000078  f7fffffe          BL       OS_CPU_SR_Restore
00007c  2049              MOVS     r0,#0x49              ;213
00007e  7028              STRB     r0,[r5,#0]            ;213
000080  4626              MOV      r6,r4                 ;214
                  |L3.130|
000082  e028              B        |L3.214|
                  |L3.132|
000084  e005              B        |L3.146|
                  |L3.134|
000086  2300              MOVS     r3,#0                 ;220
000088  2201              MOVS     r2,#1                 ;220
00008a  4619              MOV      r1,r3                 ;220
00008c  4620              MOV      r0,r4                 ;220
00008e  f7fffffe          BL       OS_EventTaskRdy
                  |L3.146|
000092  7aa0              LDRB     r0,[r4,#0xa]          ;219
000094  2800              CMP      r0,#0                 ;219
000096  d1f6              BNE      |L3.134|
000098  203f              MOVS     r0,#0x3f              ;223
00009a  73e0              STRB     r0,[r4,#0xf]          ;223
00009c  2100              MOVS     r1,#0                 ;224
00009e  7421              STRB     r1,[r4,#0x10]         ;224
0000a0  2000              MOVS     r0,#0                 ;226
0000a2  7020              STRB     r0,[r4,#0]            ;226
0000a4  480e              LDR      r0,|L3.224|
0000a6  6800              LDR      r0,[r0,#0]            ;227  ; OSEventFreeList
0000a8  6060              STR      r0,[r4,#4]            ;227
0000aa  2000              MOVS     r0,#0                 ;228
0000ac  8120              STRH     r0,[r4,#8]            ;228
0000ae  480c              LDR      r0,|L3.224|
0000b0  6004              STR      r4,[r0,#0]            ;229  ; OSEventFreeList
0000b2  4648              MOV      r0,r9                 ;230
0000b4  f7fffffe          BL       OS_CPU_SR_Restore
0000b8  2f01              CMP      r7,#1                 ;231
0000ba  d101              BNE      |L3.192|
0000bc  f7fffffe          BL       OS_Sched
                  |L3.192|
0000c0  2000              MOVS     r0,#0                 ;234
0000c2  7028              STRB     r0,[r5,#0]            ;234
0000c4  2600              MOVS     r6,#0                 ;235
0000c6  e006              B        |L3.214|
                  |L3.200|
0000c8  4648              MOV      r0,r9                 ;239
0000ca  f7fffffe          BL       OS_CPU_SR_Restore
0000ce  2007              MOVS     r0,#7                 ;240
0000d0  7028              STRB     r0,[r5,#0]            ;240
0000d2  4626              MOV      r6,r4                 ;241
0000d4  bf00              NOP                            ;242
                  |L3.214|
0000d6  bf00              NOP                            ;216
0000d8  4630              MOV      r0,r6                 ;244
0000da  e79e              B        |L3.26|
;;;246    #endif
                          ENDP

                  |L3.220|
                          DCD      OSIntNesting
                  |L3.224|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;280    /*$PAGE*/
;;;281    void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;283    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;284        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;285    #endif
;;;286    
;;;287    
;;;288    
;;;289    #if OS_ARG_CHK_EN > 0
;;;290        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
;;;291            return;
;;;292        }
;;;293        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;294            *perr = OS_ERR_PEVENT_NULL;
;;;295            return;
;;;296        }
;;;297    #endif
;;;298        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L4.26|
;;;299            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7020              STRB     r0,[r4,#0]
                  |L4.22|
;;;300            return;
;;;301        }
;;;302        if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
;;;303            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;304            return;
;;;305        }
;;;306        if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
;;;307            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;308            return;
;;;309        }
;;;310        OS_ENTER_CRITICAL();
;;;311        if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
;;;312            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;313            OS_EXIT_CRITICAL();
;;;314            *perr = OS_ERR_NONE;
;;;315            return;
;;;316        }
;;;317                                                          /* Otherwise, must wait until event occurs       */
;;;318        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;319        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;320        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;321        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;322        OS_EXIT_CRITICAL();
;;;323        OS_Sched();                                       /* Find next highest priority task ready         */
;;;324        OS_ENTER_CRITICAL();
;;;325        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;326            case OS_STAT_PEND_OK:
;;;327                 *perr = OS_ERR_NONE;
;;;328                 break;
;;;329    
;;;330            case OS_STAT_PEND_ABORT:
;;;331                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;332                 break;
;;;333    
;;;334            case OS_STAT_PEND_TO:
;;;335            default:        
;;;336                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;337                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;338                 break;
;;;339        }
;;;340        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;341        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;342        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;343    #if (OS_EVENT_MULTI_EN > 0)
;;;344        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;345    #endif
;;;346        OS_EXIT_CRITICAL();
;;;347    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  4834              LDR      r0,|L4.236|
00001c  7800              LDRB     r0,[r0,#0]            ;302  ; OSIntNesting
00001e  2800              CMP      r0,#0                 ;302
000020  dd02              BLE      |L4.40|
000022  2002              MOVS     r0,#2                 ;303
000024  7020              STRB     r0,[r4,#0]            ;303
000026  e7f6              B        |L4.22|
                  |L4.40|
000028  4831              LDR      r0,|L4.240|
00002a  7800              LDRB     r0,[r0,#0]            ;306  ; OSLockNesting
00002c  2800              CMP      r0,#0                 ;306
00002e  dd02              BLE      |L4.54|
000030  200d              MOVS     r0,#0xd               ;307
000032  7020              STRB     r0,[r4,#0]            ;307
000034  e7ef              B        |L4.22|
                  |L4.54|
000036  f7fffffe          BL       OS_CPU_SR_Save
00003a  4607              MOV      r7,r0                 ;310
00003c  8928              LDRH     r0,[r5,#8]            ;311
00003e  2800              CMP      r0,#0                 ;311
000040  dd08              BLE      |L4.84|
000042  8928              LDRH     r0,[r5,#8]            ;312
000044  1e40              SUBS     r0,r0,#1              ;312
000046  8128              STRH     r0,[r5,#8]            ;312
000048  4638              MOV      r0,r7                 ;313
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;314
000050  7020              STRB     r0,[r4,#0]            ;314
000052  e7e0              B        |L4.22|
                  |L4.84|
000054  4827              LDR      r0,|L4.244|
000056  6800              LDR      r0,[r0,#0]            ;318  ; OSTCBCur
000058  f8900030          LDRB     r0,[r0,#0x30]         ;318
00005c  f0400001          ORR      r0,r0,#1              ;318
000060  4924              LDR      r1,|L4.244|
000062  6809              LDR      r1,[r1,#0]            ;318  ; OSTCBCur
000064  f8810030          STRB     r0,[r1,#0x30]         ;318
000068  2000              MOVS     r0,#0                 ;319
00006a  4922              LDR      r1,|L4.244|
00006c  6809              LDR      r1,[r1,#0]            ;319  ; OSTCBCur
00006e  f8810031          STRB     r0,[r1,#0x31]         ;319
000072  4820              LDR      r0,|L4.244|
000074  6800              LDR      r0,[r0,#0]            ;320  ; OSTCBCur
000076  85c6              STRH     r6,[r0,#0x2e]         ;320
000078  4628              MOV      r0,r5                 ;321
00007a  f7fffffe          BL       OS_EventTaskWait
00007e  4638              MOV      r0,r7                 ;322
000080  f7fffffe          BL       OS_CPU_SR_Restore
000084  f7fffffe          BL       OS_Sched
000088  f7fffffe          BL       OS_CPU_SR_Save
00008c  4607              MOV      r7,r0                 ;324
00008e  4819              LDR      r0,|L4.244|
000090  6800              LDR      r0,[r0,#0]            ;325  ; OSTCBCur
000092  f8900031          LDRB     r0,[r0,#0x31]         ;325
000096  b120              CBZ      r0,|L4.162|
000098  2801              CMP      r0,#1                 ;325
00009a  d009              BEQ      |L4.176|
00009c  2802              CMP      r0,#2                 ;325
00009e  d106              BNE      |L4.174|
0000a0  e002              B        |L4.168|
                  |L4.162|
0000a2  2000              MOVS     r0,#0                 ;327
0000a4  7020              STRB     r0,[r4,#0]            ;327
0000a6  e00b              B        |L4.192|
                  |L4.168|
0000a8  200e              MOVS     r0,#0xe               ;331
0000aa  7020              STRB     r0,[r4,#0]            ;331
0000ac  e008              B        |L4.192|
                  |L4.174|
0000ae  bf00              NOP                            ;334
                  |L4.176|
0000b0  4629              MOV      r1,r5                 ;336
0000b2  4810              LDR      r0,|L4.244|
0000b4  6800              LDR      r0,[r0,#0]            ;336  ; OSTCBCur
0000b6  f7fffffe          BL       OS_EventTaskRemove
0000ba  200a              MOVS     r0,#0xa               ;337
0000bc  7020              STRB     r0,[r4,#0]            ;337
0000be  bf00              NOP                            ;338
                  |L4.192|
0000c0  bf00              NOP                            ;328
0000c2  2000              MOVS     r0,#0                 ;340
0000c4  490b              LDR      r1,|L4.244|
0000c6  6809              LDR      r1,[r1,#0]            ;340  ; OSTCBCur
0000c8  f8810030          STRB     r0,[r1,#0x30]         ;340
0000cc  4909              LDR      r1,|L4.244|
0000ce  6809              LDR      r1,[r1,#0]            ;341  ; OSTCBCur
0000d0  f8810031          STRB     r0,[r1,#0x31]         ;341
0000d4  4907              LDR      r1,|L4.244|
0000d6  6809              LDR      r1,[r1,#0]            ;342  ; OSTCBCur
0000d8  61c8              STR      r0,[r1,#0x1c]         ;342
0000da  4906              LDR      r1,|L4.244|
0000dc  6809              LDR      r1,[r1,#0]            ;344  ; OSTCBCur
0000de  6208              STR      r0,[r1,#0x20]         ;344
0000e0  4638              MOV      r0,r7                 ;346
0000e2  f7fffffe          BL       OS_CPU_SR_Restore
0000e6  bf00              NOP      
0000e8  e795              B        |L4.22|
;;;348    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L4.236|
                          DCD      OSIntNesting
                  |L4.240|
                          DCD      OSLockNesting
                  |L4.244|
                          DCD      OSTCBCur

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=1

                  OSSemPendAbort PROC
;;;383    #if OS_SEM_PEND_ABORT_EN > 0
;;;384    INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;385    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;386        INT8U      nbr_tasks;
;;;387    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;388        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;389    #endif
;;;390    
;;;391    
;;;392    
;;;393    #if OS_ARG_CHK_EN > 0
;;;394        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
;;;395            return (0);
;;;396        }
;;;397        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;398            *perr = OS_ERR_PEVENT_NULL;
;;;399            return (0);
;;;400        }
;;;401    #endif
;;;402        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000e  7820              LDRB     r0,[r4,#0]
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L5.30|
;;;403            *perr = OS_ERR_EVENT_TYPE;
000014  2001              MOVS     r0,#1
000016  7028              STRB     r0,[r5,#0]
;;;404            return (0);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;405        }
;;;406        OS_ENTER_CRITICAL();
;;;407        if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
;;;408            nbr_tasks = 0;
;;;409            switch (opt) {
;;;410                case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;411                     while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
;;;412                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;413                         nbr_tasks++;
;;;414                     }
;;;415                     break;
;;;416                     
;;;417                case OS_PEND_OPT_NONE:
;;;418                default:                                  /* No,  ready HPT       waiting on semaphore     */
;;;419                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;420                     nbr_tasks++;
;;;421                     break;
;;;422            }
;;;423            OS_EXIT_CRITICAL();
;;;424            OS_Sched();                                   /* Find HPT ready to run                         */
;;;425            *perr = OS_ERR_PEND_ABORT;
;;;426            return (nbr_tasks);
;;;427        }
;;;428        OS_EXIT_CRITICAL();
;;;429        *perr = OS_ERR_NONE;
;;;430        return (0);                                       /* No tasks waiting on semaphore                 */
;;;431    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;406
000024  7aa0              LDRB     r0,[r4,#0xa]          ;407
000026  b320              CBZ      r0,|L5.114|
000028  2600              MOVS     r6,#0                 ;408
00002a  b17f              CBZ      r7,|L5.76|
00002c  2f01              CMP      r7,#1                 ;409
00002e  d10c              BNE      |L5.74|
000030  e007              B        |L5.66|
                  |L5.50|
000032  2302              MOVS     r3,#2                 ;412
000034  2201              MOVS     r2,#1                 ;412
000036  2100              MOVS     r1,#0                 ;412
000038  4620              MOV      r0,r4                 ;412
00003a  f7fffffe          BL       OS_EventTaskRdy
00003e  1c70              ADDS     r0,r6,#1              ;413
000040  b2c6              UXTB     r6,r0                 ;413
                  |L5.66|
000042  7aa0              LDRB     r0,[r4,#0xa]          ;411
000044  2800              CMP      r0,#0                 ;411
000046  d1f4              BNE      |L5.50|
000048  e009              B        |L5.94|
                  |L5.74|
00004a  bf00              NOP                            ;417
                  |L5.76|
00004c  2302              MOVS     r3,#2                 ;419
00004e  2201              MOVS     r2,#1                 ;419
000050  2100              MOVS     r1,#0                 ;419
000052  4620              MOV      r0,r4                 ;419
000054  f7fffffe          BL       OS_EventTaskRdy
000058  1c70              ADDS     r0,r6,#1              ;420
00005a  b2c6              UXTB     r6,r0                 ;420
00005c  bf00              NOP                            ;421
                  |L5.94|
00005e  bf00              NOP                            ;415
000060  4640              MOV      r0,r8                 ;423
000062  f7fffffe          BL       OS_CPU_SR_Restore
000066  f7fffffe          BL       OS_Sched
00006a  200e              MOVS     r0,#0xe               ;425
00006c  7028              STRB     r0,[r5,#0]            ;425
00006e  4630              MOV      r0,r6                 ;426
000070  e7d3              B        |L5.26|
                  |L5.114|
000072  4640              MOV      r0,r8                 ;428
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  2000              MOVS     r0,#0                 ;429
00007a  7028              STRB     r0,[r5,#0]            ;429
00007c  bf00              NOP                            ;430
00007e  e7cc              B        |L5.26|
;;;432    #endif
                          ENDP


                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=1

                  OSSemPost PROC
;;;452    
;;;453    INT8U  OSSemPost (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;454    {
000002  4604              MOV      r4,r0
;;;455    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;456        OS_CPU_SR  cpu_sr = 0;
000004  2500              MOVS     r5,#0
;;;457    #endif
;;;458    
;;;459    
;;;460    
;;;461    #if OS_ARG_CHK_EN > 0
;;;462        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;463            return (OS_ERR_PEVENT_NULL);
;;;464        }
;;;465    #endif
;;;466        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L6.16|
;;;467            return (OS_ERR_EVENT_TYPE);
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;468        }
;;;469        OS_ENTER_CRITICAL();
;;;470        if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
;;;471                                                          /* Ready HPT waiting on event                    */
;;;472            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;473            OS_EXIT_CRITICAL();
;;;474            OS_Sched();                                   /* Find HPT ready to run                         */
;;;475            return (OS_ERR_NONE);
;;;476        }
;;;477        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;478            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;479            OS_EXIT_CRITICAL();
;;;480            return (OS_ERR_NONE);
;;;481        }
;;;482        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;483        return (OS_ERR_SEM_OVF);
;;;484    }
00000e  bd70              POP      {r4-r6,pc}
                  |L6.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4605              MOV      r5,r0                 ;469
000016  7aa0              LDRB     r0,[r4,#0xa]          ;470
000018  b160              CBZ      r0,|L6.52|
00001a  2300              MOVS     r3,#0                 ;472
00001c  2201              MOVS     r2,#1                 ;472
00001e  4619              MOV      r1,r3                 ;472
000020  4620              MOV      r0,r4                 ;472
000022  f7fffffe          BL       OS_EventTaskRdy
000026  4628              MOV      r0,r5                 ;473
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  f7fffffe          BL       OS_Sched
000030  2000              MOVS     r0,#0                 ;475
000032  e7ec              B        |L6.14|
                  |L6.52|
000034  8920              LDRH     r0,[r4,#8]            ;477
000036  f64f71ff          MOV      r1,#0xffff            ;477
00003a  4288              CMP      r0,r1                 ;477
00003c  d207              BCS      |L6.78|
00003e  8920              LDRH     r0,[r4,#8]            ;478
000040  1c40              ADDS     r0,r0,#1              ;478
000042  8120              STRH     r0,[r4,#8]            ;478
000044  4628              MOV      r0,r5                 ;479
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  2000              MOVS     r0,#0                 ;480
00004c  e7df              B        |L6.14|
                  |L6.78|
00004e  4628              MOV      r0,r5                 ;482
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2032              MOVS     r0,#0x32              ;483
000056  e7da              B        |L6.14|
;;;485    
                          ENDP


                          AREA ||i.OSSemQuery||, CODE, READONLY, ALIGN=1

                  OSSemQuery PROC
;;;506    #if OS_SEM_QUERY_EN > 0
;;;507    INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;508    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;509    #if OS_LOWEST_PRIO <= 63
;;;510        INT8U     *psrc;
;;;511        INT8U     *pdest;
;;;512    #else
;;;513        INT16U    *psrc;
;;;514        INT16U    *pdest;
;;;515    #endif
;;;516        INT8U      i;
;;;517    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;518        OS_CPU_SR  cpu_sr = 0;
000008  f04f0900          MOV      r9,#0
;;;519    #endif
;;;520    
;;;521    
;;;522    
;;;523    #if OS_ARG_CHK_EN > 0
;;;524        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;525            return (OS_ERR_PEVENT_NULL);
;;;526        }
;;;527        if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
;;;528            return (OS_ERR_PDATA_NULL);
;;;529        }
;;;530    #endif
;;;531        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d002              BEQ      |L7.24|
;;;532            return (OS_ERR_EVENT_TYPE);
000012  2001              MOVS     r0,#1
                  |L7.20|
;;;533        }
;;;534        OS_ENTER_CRITICAL();
;;;535        p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
;;;536        psrc                   = &pevent->OSEventTbl[0];
;;;537        pdest                  = &p_sem_data->OSEventTbl[0];
;;;538        for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
;;;539            *pdest++ = *psrc++;
;;;540        }
;;;541        p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
;;;542        OS_EXIT_CRITICAL();
;;;543        return (OS_ERR_NONE);
;;;544    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L7.24|
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  4681              MOV      r9,r0                 ;534
00001e  7aa0              LDRB     r0,[r4,#0xa]          ;535
000020  71a8              STRB     r0,[r5,#6]            ;535
000022  f104070b          ADD      r7,r4,#0xb            ;536
000026  1cae              ADDS     r6,r5,#2              ;537
000028  f04f0800          MOV      r8,#0                 ;538
00002c  e007              B        |L7.62|
                  |L7.46|
00002e  f8170b01          LDRB     r0,[r7],#1            ;539
000032  f8060b01          STRB     r0,[r6],#1            ;539
000036  f1080001          ADD      r0,r8,#1              ;538
00003a  f00008ff          AND      r8,r0,#0xff           ;538
                  |L7.62|
00003e  f1b80f04          CMP      r8,#4                 ;538
000042  dbf4              BLT      |L7.46|
000044  8920              LDRH     r0,[r4,#8]            ;541
000046  8028              STRH     r0,[r5,#0]            ;541
000048  4648              MOV      r0,r9                 ;542
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;543
000050  e7e0              B        |L7.20|
;;;545    #endif                                                     /* OS_SEM_QUERY_EN                          */
                          ENDP


                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=1

                  OSSemSet PROC
;;;572    #if OS_SEM_SET_EN > 0
;;;573    void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;574    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;575    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;576        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;577    #endif
;;;578    
;;;579    
;;;580    
;;;581    #if OS_ARG_CHK_EN > 0
;;;582        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
;;;583            return;
;;;584        }
;;;585        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;586            *perr = OS_ERR_PEVENT_NULL;
;;;587            return;
;;;588        }
;;;589    #endif
;;;590        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L8.26|
;;;591            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7028              STRB     r0,[r5,#0]
                  |L8.22|
;;;592            return;
;;;593        }
;;;594        OS_ENTER_CRITICAL();
;;;595        *perr = OS_ERR_NONE;
;;;596        if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
;;;597            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;598        } else {                                          /* No                                            */
;;;599            if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
;;;600                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;601            } else {
;;;602                *perr              = OS_ERR_TASK_WAITING;
;;;603            }
;;;604        }
;;;605        OS_EXIT_CRITICAL();
;;;606    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L8.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;594
000020  2000              MOVS     r0,#0                 ;595
000022  7028              STRB     r0,[r5,#0]            ;595
000024  8920              LDRH     r0,[r4,#8]            ;596
000026  2800              CMP      r0,#0                 ;596
000028  dd01              BLE      |L8.46|
00002a  8126              STRH     r6,[r4,#8]            ;597
00002c  e005              B        |L8.58|
                  |L8.46|
00002e  7aa0              LDRB     r0,[r4,#0xa]          ;599
000030  b908              CBNZ     r0,|L8.54|
000032  8126              STRH     r6,[r4,#8]            ;600
000034  e001              B        |L8.58|
                  |L8.54|
000036  2049              MOVS     r0,#0x49              ;602
000038  7028              STRB     r0,[r5,#0]            ;602
                  |L8.58|
00003a  4638              MOV      r0,r7                 ;605
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  bf00              NOP      
000042  e7e8              B        |L8.22|
;;;607    #endif
                          ENDP

